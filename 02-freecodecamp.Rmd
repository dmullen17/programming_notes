# JavaScript Algorithms and Data Structures FCC 
These are my notes from the JavaScript Algorithms and Data Structures certification from the<a href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript"> FreeCodeCamp lessons</a>

## ES6 
Arrow function defintion syntax: 
```
let printAandB = (a, b) => {
  console.log(`${a} = a and ${b} = b`);
}
```

## Regex 
Example using the .test() method - pretty weird syntax with the string as the input. 
```
let myString = "freeCodeCamp";
let fccRegex = /freecodecamp/; // Change this line
let result = fccRegex.test(myString);
```
  
+ .match() extracts matches 
+ uses flags: i = case insensitive, g = more than the first match 
+ you can put whatever you want in a class: [aeiou] or [a-f], [a-z] etc. 
+ lazy matching - finds the smallest part of the string that matches the pattern
+ [\w] matches alphanumerics, [\W] matches non alphanumerics 
+ [\d] matches digits, [\D] is the inverse 
+ [\s] matches all whitespace characters, [\S] is the inverse 
+ `?` checks for all or none (think of it as optional)
+ .trim() and .replace() methods exist 


## Debugging 
Overall this wasn't the most informative section.  It mainly focused on common errors 
rather than debugging techniques.  I've done quite a bit of debugging though so I'm not 
exactly sorry that this section was short.
  
+ Use `console.log(typeof variable_name)` to return the type. 
    + Interestingly this isn't a function you wrap the object in.
+ OBOE - refers to off by one errors
   + if you access an out range index it `undefined` is usually the output
   + the following syntax should avoid this `for (let i = 0; i < obj.length; i++)`
<br> 


## Data Structures 
+ Arrays can store other arrays / JS objects 
+ `Array.push` adds elements to the end. `Array.unshift()` to the beginning.
    + .pop removes from the end / .shift removes from the beginning
+ `Array.slice(0:9)` - removes the first 10 elements 

The third (optional) argument in `splice` can replace an element.  This is a cool 
example of using it to update a color scheme: 
```
function colorChange(arr, index, newColor) {
  arr.splice(index, 1, newColor);
  return arr;
}

let colorScheme = ['#878787', '#a08794', '#bb7e8c', '#c9b6be', '#d1becf'];

colorScheme = colorChange(colorScheme, 2, '#332327');
// we have removed '#bb7e8c' and added '#332327' in its place
// colorScheme now equals ['#878787', '#a08794', '#332327', '#c9b6be', '#d1becf']
```
+ `slice` extracts array elements but doesn't modify the original array
    + `splice` is the same but it removes the selected elements 
+ the spread operator `...` allows us to copy arrays / insert them into other arrays 
    + `let thisArray = ['sage', 'rosemary', 'parsley', 'thyme'];`
    + `let thatArray = ['basil', 'cilantro', ...thisArray, 'coriander'];`
+ `arr.indexOf('element')` returns the index or -1 if it DNE
+ `arr.includes()` returns a boolean 
<br> 

Basic object operations
+ Use the dot operator to access properties `obj.prop1.prop2 etc.`
+ You can also use bracket notation `obj[key1][key2]`
+ You can use the delete keyword to remove properties: `delete obj.prop1;`
+ `Obj.hasOwnProperty(prop)` returns a boolean - really useful! 
+ We can iterate through keys in an object: 
    + `for (let key in obj) {obj[key]...}`
+ `Object.keys(input_obj)` returns all the keys in an object. 


## Basic Algorithm Scripting 
I included algorithms because I either found them interesting, learned something new, or found them difficult to puzzle through.  
  
**1.** Cool reverse way to reverse a string with array methods: 
```
function reverseString(str) {
  return str.split('').reverse().join('');
}
```
  
**2.** Recursion solution to factorial problem: 
```
function factorialize(num) {
  if (num === 0) { return 1; }
  return num * factorialize(num-1);
}
```
  
**3.** Find the longest word in a string, my solution:
```
function findLongestWordLength(str) {
  let lengths = str.split(' ').map(word => word.length)
  return Math.max(...lengths);
}
```

**4.** Match 'x' amount of characters at the end of a string:
```
function confirmEnding(str, target) {
  return str.slice(str.length - target.length) === target;
}
```

**5.** My solution to: Title case every word in a string. The key here was remembering that the string method `.replace` takes regex as an input and then a callback function.  I had to use map in order to use replace on every element of the array.  
```
function titleCase(str) {
  return str.toLowerCase().split(' ').map(el => el.replace(/^.{1}/, letter => letter.toUpperCase())).join(' ');
}
```

**6.** Remove all "falsy" values from an array.  This method uses the filter function that takes a callback function and filters out values based on true/false output.  The `Boolean` functions returns T/F based on the input.    
```
function bouncer(arr) {
  // Don't show a false ID to this bouncer.
  return arr.filter(Boolean)
}
```

**7.** Check if the all the characters in arr[1] are in arr[0]. My weird solution below.  I could have incorporated `.indexOf` instead of findIndex, and `.every` which is the same as `all` in R.   
```
function mutation(arr) {
  let arr0 = arr[0].toLowerCase().split('');
  let arr1 = arr[1].toLowerCase().split('');
  return arr1.map(el => arr0.findIndex(letter => el===letter)).includes(-1) ? false : true;
}
```

**8.** Split an array into groups of `size` and return then in a two dimensional array.  The first solution is mine where I used a bunch of additional counter variables.  The second solution is really elegant. It creates a newArr to store results in.  The while loop keeps running while there are elements left in `arr`.  Then we push and splice until `arr` is empty.
```
function chunkArrayInGroups(arr, size) {
  let newArr = [];
  let start = 0;
  let end = size; 
  let numIterations = Math.ceil(arr.length/size);

  for (let i = 0; i < numIterations; i++) {
    if (end > arr.length) {
      newArr[i] = arr.slice(start, arr.length);
    } else {
    newArr[i] = arr.slice(start, end);
    start += size; 
    end += size; 
    }
  }
  return newArr;
}
function chunkArrayInGroups(arr, size) {
  var newArr = [];
  while (arr.length) {
    newArr.push(arr.splice(0,size));
  }
return newArr;
}
```

## Object Oriented Programming
The software development process first defines a problem, then presents a solution. Object oriented programming is one of several major approaches to the software development process. As its name implies, object oriented programming organizes code into object definitions. These are sometimes called classes, and they group together data with related behavior. The data is an object's attributes, and the behavior (or functions) are methods.

+ object declaration: ```let object = {property: "value"}`
+ access properties with the dot operator: `object.property`
+ add a method to an object 
    +
    ```
let dog = {
  name: "Spot",
  numLegs: 4,
  sayLegs: function() {return `This dog has ${this.numLegs} legs.`}
};
```
+ Create a class constructor: 
    +
```
function Dog(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 4;
}
```
+ check that a variable is of a Class using `variable instanceOf class;`
+ own properties are defined directly on an object (not inherited)
    + You can loop through an objects properties (AND prototype properties): `for (let property in object){}`
+ prototype is an object shared among all instance of a class 
    + we can modify the prototype directly with: `Dog.prototype.numLegs = 4;`
+ we can check if the constructor is of a specific class: 
    +
```
let joinDogFraternity = (candidate) => {
  return candidate.constructor === Dog ? true : false;
}
```
+ Set methods in the prototype.  Also includes shorthand method definitions: 
    + when manually setting the prototype of an object it deletes the constructor.  Remember to include the `constructor` property in the prototype.
    +
```
function Dog(name) {
  this.name = name; 
}
Dog.prototype = {
  numLegs: 4,
  eat() {
    console.log('nom nom nom');
  },
  describe() {
    console.log(`My name is ${this.name}`);
  }
};
```
+ `isProtoTypeOf` method: 
    +
```
function Dog(name) {
  this.name = name;
}
let beagle = new Dog("Snoopy");
Dog.prototype.isPrototypeOf(beagle);
```
+ using inheritance means you won't repeat yourself (DRY)
+ `superType` = parent
+ this is the same as using the `new` operator: 
    + `let animal = Object.create(Animal.prototype);`
    + Object.create(obj) creates a new object, and sets obj as the new object's prototype
+ `subtype` = child 
    + set the prototype of the subtype (or child)—in this case, Bird—to be an instance of Animal: 
    + `Bird.prototype = Object.create(Animal.prototype);`
+ When an object inherits its prototype from another object, it also inherits the supertype's constructor property.  You need to reset the constructor property manually: `Bird.prototype.constructor = Bird;`
+ We can overwrite a prototype method by using the same name. 
+ `Mixin` a generic function we can use to give unrelated objects methods
    +
```
let bird = {
  name: "Donald",
  numLegs: 2
};
let boat = {
  name: "Warrior",
  type: "race-boat"
};
// Create a Mixin function
let glideMixin = function(obj) {
    obj.glide = function() {
        console.log('gliding!');
    }
};
glideMixin(bird);
glideMixin(boat);
bird.glide();
```

**Use Closures to create private variables:**  
We can make properties private by creating a variable within the constructor function. The scope of the variable is now in the constructor function -> so the variable can only be accessed or changed by methods within the constructor function.  
```
function Bird() {
  let weight = 15;
  this.getWeight = function() {//publicly available method
    return weight;
  }
}
```

**Use an IIFE to create a module:**  
Note that you have an immediately invoked function expression (IIFE) that returns an object motionModule. This returned object contains all of the mixin behaviors as properties of the object. The advantage of the module pattern is that all of the motion behaviors can be packaged into a single object that can then be used by other parts of your code. Here is an example using it:
```
let motionModule = (function () {
  return {
    glideMixin: function (obj) {
      obj.glide = function() {
        console.log("Gliding on the water");
      };
    },
    flyMixin: function(obj) {
      obj.fly = function() {
        console.log("Flying, wooosh!");
      };
    }
  }
}) (); // The two parentheses cause the function to be immediately invoked
motionModule.glideMixin(duck);
duck.glide();
```
<hr>


## Function Programming Challenges 
Functional programming is an approach to software development based around the evaluation of functions. Like mathematics, functions in programming map input to output to produce a result. You can combine basic functions in many ways to build more and more complex programs. The functional programming software development approach breaks a program into small, testable parts. This section covers basic functional programming principles in JavaScript.

+ Functional programming follows a few core principles:
+ Functions are independent from the state of the program or global variables. They only depend on the arguments passed into them to make a calculation
+ Functions try to limit any changes to the state of the program and avoid changes to the global objects holding data
+ Functions have minimal side effects in the program  
