# APIs and microservices 
These are my notes from the APIs and microservices [certification](https://learn.freecodecamp.org/apis-and-microservices/managing-packages-with-npm) from FreeCodeCamp! 

## NPM
The Node Package Manager (npm) is a command-line tool used by developers to share and control modules (or packages) of JavaScript code written for use with Node.js. When starting a new project, npm generates a package.json file. This file lists the package dependencies for your project. Since npm packages are regularly updated, the package.json file allows you to set specific version numbers for each dependency. This ensures that updates to a package don't break your project.

+ npm saves packages in a folder named nodemodules. These packages can be installed in two ways:
    + globally in a root nodemodules folder, accessible by all projects.
    + locally within a project's own node_modules folder, accessible only to that project.

Most developers prefer to install packages local to each project to create a separation between the dependencies of different projects. 

### package.json
The file package.json is the center of any Node.js project or npm package. It stores information about your project just like the <head>-section in a HTML document describes the content of a webpage. The package.json consists of a single JSON-object where information is stored in "key": value-pairs. There are only two required fields in a minimal package.json - name and version - but it’s a good practice to provide additional information about your project that could be useful to future users or maintainers.
```
"author" : "Dominic Mullen",
"description" : "learning about npm",
"keywords": [
  "learning", "npm", "freecodecamp", "backend"
  ],
"license": "MIT",
"version": "1.5", 
"dependencies": {
  "moment": "~2.10.2",
  "package": "^1.1.1"
}
```

#### SemVer
Semantic Versioning is an industry standard for versioning software. Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, and PATCH version when you make backwards-compatible bug fixes.

+ Including a `~` in `"moment": "~2.10.2"` allows npm to look for and install any `PATCH` fixes.
+ Including a `^` in `"moment": "^2.10.2"` allows npm to look for and install any `MINOR` fixes.


<hr>


## Node.js and Express
Node.js is a JavaScript tool that allows developers to write backend (server-side) programs in JavaScript. Node.js comes with a handful of built-in modules—small, independent programs—that help facilitate this purpose. Some of the core modules include:

+ HTTP: a module that acts as a server
+ File System: a module that reads and modifies files
+ Path: a module for working with directory and file paths
+ Assertion Testing: a module that checks code against prescribed constraints
+ Express, while not included with Node.js, is another module often used with it. Express runs between the server created by Node.js and the frontend pages of a web application. Express also handles an application's routing. Routing directs users to the correct page based on their interaction with the application.

Set up a node.js server using express and tell it to listen on `port` 
```
var express = require('express');
var app = express();
app.listen(process.env.PORT || 3000 );
```

### Express Routes
 In Express, routes takes the following structure: app.METHOD(PATH, HANDLER). METHOD is an http method in lowercase. PATH is a relative path on the server (it can be a string, or even a regular expression). HANDLER is a function that Express calls when the route is matched.
 
Example: 
```
app.get('/', function(req, res) {
  res.send('Hello Express');
});
```

Instead of serving a message, like we do above, we can respond with a file.  Here we serve an html file. This loads a big html heading and an input form.  You basically use this to route files depending where a visitor goes.  
```
app.get('/', function(req, res) {
  const filePath = __dirname + '/views/index.html';
  console.log(filePath);
  res.sendFile(filePath);
});
```

### Serve Static Assests 
An HTML server usually has one or more directories that are accessible by the user. You can place there the static assets needed by your application (stylesheets, scripts, images). In Express you can put in place this functionality using the middleware express.static(path), where the parameter is the absolute path of the folder containing the assets.
```
 app.use(express.static(__dirname + "/views"));
```
It seems like whenever we call a `use` method the middleware also loads the css files located there.  Idk yet though - this section seems blackboxy

### JSON API
While an HTML server serves (you guessed it!) HTML, an API serves data. A REST (REpresentational State Transfer) API allows data exchange in a simple way, without the need for clients to know any detail about the server. The client only needs to know where the resource is (the URL), and the action it wants to perform on it (the verb). The GET verb is used when you are fetching some information, without modifying anything. These days, the preferred data format for moving information around the web is JSON. Simply put, JSON is a convenient way to represent a JavaScript object as a string, so it can be easily transmitted

When a user navigates to the following endpoint: `/json` they are served the following json: `{"message": "Hello json"}"`.  Javascript objects should be passed in as objects (not strings). 
```
app.get('/json', function(req, res) {
  res.json({"message": "Hello json"});
});
```

+ .env file is a hidden file that is used to pass environment variables to your application. 
+ environment variables are accessible from the app as process.env.VAR_NAME. The process.env object is a global Node object, and variables are passed as strings. By convention, the variable names are all uppercase, with words separated by an underscore.
+ there cannot be space around the equals sign when you are assigning values to your variables, e.g. VAR_NAME=value