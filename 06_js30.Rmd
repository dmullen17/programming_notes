#JS30 
These are my notes from Wes Bos's free Javscript 30 [course](https://javascript30.com/)

## Drumkit 

### Center div within div 
We need to add text-align: center to the parent div to center text horizontally.  Then in the child div elements we add top 50% and position relative to center them vertically.  

```
.parent-div {
  text-align: center;
}

.child-div {
  top: 50%; 
  position: relative; 
}
```

### document.querySelectorAll
**Add a class to a div on keypress:**
This method returns a NodeList element so it's necessary to use indexing to find the one we want.  This is usually [0] if we're using data attributes to search. Here we use querySelectorAll method to find the div where we set the data attribute `data-key` equal to the `event.keyCode`

```{html, javascript}
<!DOCTYPE html>
<html>
<div class='key' id='key-1' data-key='65'><h2>A</h2><p class='key-p'>CLAP</p></div>
<script> 
window.addEventListener('keypress', function(event){
    console.log(event.keyCode);
    document.querySelectorAll(`[data-key='${event.keyCode}']`)[0].classList.add('key-press');
</script>
</html>
```

### Event Bubbling
When an event is triggered it will "bubble" up through its parent elements until it reaches the window. If it reaches any event handlers those will process if they match the event.  When we have multiple children we typically add an event handler to their parent element so we only need to write the code once. 

+ Example of event bubbling 

```{html}
<!DOCTYPE html>
<html>
    <head>
        <style type='text/css'>  
            .styling {
                display: table-cell;
                border: 1px solid black; 
                padding: 20px; 
                text-align: center; 
            }
        </style>
    </head>
    <body>
        <div class='styling' onclick='alert("DIV CLICKED")'>Div element
            <span class='styling' onclick='alert("Span clicked")'>Span element
                <input type='button' class='styling' value='Click me!' onclick='alert("button clicked")'>
            </span>
        </div>
    </body>
</html>
```

#### 'this' in event bubbling
`this` refers to the current element to which the event is bubbled. 

+ Example using `this` in event bubbling.  Not a great example because of the for loop.  

```
<!DOCTYPE html>
<html>
    <head>
        <style type='text/css'>  
            .styling {
                display: table-cell;
                border: 1px solid black; 
                padding: 20px; 
                text-align: center; 
            }
        </style>
    </head>
    <body>
        <div id='div1' class='styling' onclick="changeBorder()">div1
            <div id='div2' class='styling' onclick ="changeBorder()">div2
                <div id='div3' class='styling'>div3</div>
            </div>
        </div>
    </body>
    <script>
        let divElements = document.getElementsByTagName('div');
        for (let i =0; i < divElements.length; i++) {
            divElements[i].onclick = function() {
                this.style.border = '3px solid pink';
                alert(this.getAttribute('id') + 'color changed');
            };
        }
        
    </script>
</html>
```

#### Stop event bubbling
In IE8 and earlier versions we use `event.cancelBubble = true`, with all other browsers we use `event.stopPropogation()`

### Transition end event 
Similar to a click event - when an element transitions it fires off a transition end event that says "I'm finished transitioning".  In this case elements are scaling up by 1.1 and making the border larger.  Each CSS property that transitions records its own event (there will likely be lots of transition events in adding / removing a class).

+ In this example: this is always equal to what got called against it - in this case "addEventListener" was called against key --> so this = key

```
const keys = document.querySelectorAll('.key');
// loop over the NodeList to add event listeners
keys.forEach(key => key.addEventListener('transitionend', removeTransition));

function removeTransition(e) {
    console.log(e); 
    // this shows a ton of events - one for each property
    if (e.propertyName !== 'transform') return; // skip the event 
    console.log(this); // see what this is 
    // this is always equal to what got called against it - in this case "addEventListener" was called against key --> so this = key.
};
```

<hr>

## JS Clock

### Center div using translate
The translate() CSS function repositions an element in the horizontal and/or vertical directions. In this example we transform it by subtracting 50% of it's width from the X-direction.  Thus - left: 50% and transform(-50%) center it horizontally.  The same is true vertically.  

```{html}
<!DOCTYPE html>
<html>
    <head>
        <style>
            .centered-div {
                background-color: black;
                position: absolute;
                height: 500px;
                width: 350px;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
        </style>
    </head>
    <body>
        <div class='centered-div'></div>
    </body>
</html>
```

### Center div using flexbox

```
body {
    display: flex;
    min-height: 100vh;
    align-items: center;
}

.clock {
    margin: auto;
}
```

### box shadow

+ `0 0 0 4px rgba(0,0,0,0.1)` - applies an outer shadow to our clock face 
+ the next one has `inset` which applies it on the inside of the clock diameter
+ 

```
box-shadow:
0 0 0 4px rgba(0,0,0,0.1),
inset 0 0 0 3px #EFEFEF,
inset 0 0 10px black,
0 0 10px rgba(0,0,0,0.2);
```

### position: relative 
We need a div with relative position to place our hand divs.  These three will be absolutely positioned (i.e. stacked on top of each other).  This is necessary so they all rotate from the origin

### Setup Description 
The background is standard.  We turn `body` into a flex container with min-height: 100vw and `align-items` and `justify-content` set to center to get the clock in the middle of the flex container.  The clock div we style.  Inside the clock div we create another with 100% height and width with positition set to relative - this is so we can use absolute positioning on the clock hands divs.  For clock hands we set their height, width, and background to create the slim rectangle, next we set top to 50% to move it to the center of the div.  Finally we set the position to absolute to stack them on top of each other.  

```
html {
    background: #018DED url(http://unsplash.it/1500/1000?image=881&blur=50);
    background-size: cover;
    font-family: 'helvetica nue';
    font-size: 10px;
}

body {
    display: flex;
    flex: 1;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
}

.clock {
    height: 30em;
    width: 30em;
    border: 20px solid white;
    border-radius: 50%;
    box-shadow: 0 0 0 4px rgba(0, 0, 0, .1),
        inset 0 0 0 3px #EFEFEF,
        inset 0 0 10px black,
        0 0 10px rgba(0,0,0,0.2);
}

.clock-face {
    height: 100%; 
    width: 100%; 
    position: relative;
    transform: translateY(-3px); /*accounts for half the height of the clock hands */
}

.hand {
    background: black;
    height: 6px;
    width: 50%;
    position: absolute;
    top: 50%;
}
```

### transform-origin
Updates where the origin is in an element.  The default is 50%.  Changing it to 100% makes the origin the right most side of the X-axis.
```
transform-origin: 100%;
```

### transition timing 
Another way to set transition timing 
```
transition: all .05s;
transition-timing-function: all cubic-bezier(.1, 2.7, .65, 1);
```

### JS Logic 
The logic here is fairly simple.  We run a function `setDate` every one second.  Each second we create a new Date object that has methods for extracting the current second, minute, and hour.  We update the CSS of each of the three hand div elements based on the current sec, min, hour, converted into degrees.  We update the `transform: rotate(xdeg);` property of each of them.  We add a cubic-bezier timing that creates a tic effect to these `transition` events.  

```
function setDate() {
    // console.log('hi');
    const now = new Date();
    const seconds = now.getSeconds();
    const secondsDegrees = (seconds/60)*360 + 90;
    //console.log(secondsDegrees);
    if (secondsDegrees == 90) secondHand.style.transition = '0s';
    // console.log(seconds);
    secondHand.style.transform = `rotate(${secondsDegrees}deg)`;
    
    const minutes = now.getMinutes();
    const minutesDegrees = (minutes/60)*360 + 90;
    if (minutesDegrees == 90) secondHand.style.transition = '0s';
    minHand.style.transform = `rotate(${minutesDegrees}deg)`;
    
    const hours = now.getHours();
    // console.log(hours); - base 24
    const hoursDegrees = (hours/12)*360 + 90;
    if (hoursDegrees == 90) secondHand.style.transition = '0s';
    hourHand.style.transform = `rotate(${hoursDegrees}deg)`;
}
```

<hr>

## CSS Variables 

### slider input 
The following code generates a slider input button. We can also set `min` and `max` attributse on the slider. 
```
<input type='range' min='10' max='200' value='10'>
```

### Access data attributes 
We can access data attributes using an event listener.  Upon an event we can console log: `this.dataset`.  This will return a data object of all properties that are prefixed with the `data-` attribute.  
```
<input type='range' min='0' max='100' value='50' data-sizing='px'>
<script>
const input = document.querySelector('input'); 
input.addEventListener('change', function(event) {
  console.log(this.dataset);
})
</script>
```

### Arrow function callback
With arrow functions as callback functions we do not get access to the `this` variable.  Instead it is set to the global window. This event listener logs the window instead of the value of the range <input> element that we added the event listener to.



```
gradientStart.addEventListener('change', () => {
    console.log(this); // why is it logging the window?
    root.style.setProperty('--gradient-start', this.value);
});
```

## Array Cardio 1 

### sort
The `sort` method sorts an array based on the values the callback function calculates.  If we use (a, b) => return a - b, and the first two elements of an array are 40 and 100, then it will return -60, a negative value, so it will sort 40 lower than 100.


### reduce
The first two input values to reduce are to total and currentValue. I was thinking of it too often as index elements 0 and 1, then 0+1, and 2, etc.  The first iteration of this is actually the unitialized variable "total" and index element 0.  We here set the initial value of total to zero.  
```
const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];
    let numCars6 = data.reduce((total, currentValue) => total + (currentValue === 'car' ? 1 : 0), initialValue = 0);
```
We can also use an object as a way to keep track of multiple fields when using reduce instead of an integer. Here we set the intial value to an empty object, initialize an obj[item] to 0 if it DNE to dynmically populate the object, then increment the count.
```
const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];
let counts = data.reduce(function(obj, item) {
  if (!obj[item]) {
    obj[item] = 0;
  }
  obj[item] ++;
  return obj;
}, {})
```

### console.table
This function outputs objects in a stylized table - makes it really easy to read.  

### map 
Good way to conceptualize map is like a factory machine. It will put a stamp on each item -> or take in X items, do something to them, and return the same amount of items.   

### Turn a NodeList into an Array
We can't use some methods on nodeLists - like map. It's better to turn then into arrays.  We can either wrap a NodeList in `Array.from()`, or enclose it in brackets and use the spread operator. 

<br>

## Flex Panels
This project uses alot of nested flexboxes.  The 5 panels are on flexbox with items centered and content center-justified.  Next the 3 paragraph elements in each panel are a flex grid.  Items are centered and we used flex: 1 to get each of them to take up 1/3 of the space.  Finally each of the paragraph elements are flex boxes with items centered to get the text inside of the paragraphs evenly centered.  

### Combinators 

A CSS selector can contain more than one simple selector. Between the simple selectors, we can include a combinator.

There are four different combinators in CSS3:

descendant selector (space)
child selector (>)
adjacent sibling selector (+)
general sibling selector (~)

This selects all direct child elements of `.panel` and applies margin: 0 to them
```
.panel > * {
    margin: 0;
}
```

### box-shadow
[https://css-tricks.com/almanac/properties/b/box-shadow/](https://css-tricks.com/almanac/properties/b/box-shadow/)
box-shadow: inset 0 0 0 5px rgba(255,255,255,0.1);

### transition 
With the transition property you specify a property, time, and cubic bezier function to specify how a transition animation will play out.  When one of these properties is changed either by a class addition or JS these timing effects will apply.  
```
.panel {
transition:
  font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),
  flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),
  background 0.2s;
}
```

### psuedo-classes
List of psuedo classes: https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes

### multiple psuedoclass rules 
We can create multiple psuedoclass CSS rules for one CSS class.  In the following example we have one class: `open-active` with two different psuedoclass rules applied to it. When we apply the `open-active` class to the div element with class `panel` the psuedoclass rules are applied to its first and last children. 

```
.panel p:first-child {
    transform: translateY(-100%);
}
.panel.open-active p:first-child {
    transform: translateY(0);
}
.panel p:last-child {
    transform: translateY(100%);
}
.panel.open-active p:last-child {
    transform: translateY(0);
}
```

### flex: 1
```
flex: 1; /* evenly distribute items among space */
```
if we give one of the 12 elements here a `flex:5` then it will takes up 5 times as much space as the other 11 items that have `flex:1`

### Run on pageload
If we have a callback function that's invoked in the event listener then it will run on pageload.  We just want to give a callback function something to reference - which is why we don't immediately invoke it with braces.  Example of immediately invoking an event listener callback function 
```
panels.forEach(panel => panel.addEventListener('click', toggleOpen()));
```

<br>

## Ajax Type Ahead 

### Style input placeholder text 
For this we use a psuedoclass to style the text.  
```
#search-main::placeholder {
    color: red;
}
```

+ `box-sizing: border-box` If we set the width of an element to 300px it will often appear bigger because it's border and padding are added to that.  If we set `box-sizing` to `border-box` then the box will always be 300px wide, regardless of what you change border or padding to.  
+ `*, *:before, *:after {box-sizing: inherit;}` this causes elements to inherit the `box-sizing` property from their parents.  This makes it easier when incorporating a component that doesn't use `border-box` to make the rest of its children inherit the `box-sizing` property that we will set at the top level of the component.  At least that what I understood from this [arcticle](https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/)

### fetch 
fetch function gets a URL endpoint then returns a promise object. We call `.then` to return the blob of data object.  From here we need to convert it to the format that we want.  If we look at the object's prototype in this case we see that there is a `.json()` method we can use.  That returns another promise which we need to call `.then` on to get our data.

```
const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';
    
const cities = []; 
    
const prom = fetch(endpoint);
console.log(prom);
// from that it will return a blob of data 
fetch(endpoint).then(blob => console.log(blob));

fetch(endpoint)
    .then(blob => blob.json())
    .then(data => console.log(data));

// Now we can add the data to our cities const using the spread operator and .push.  We use the spread operator b/c it will be a nested array otherwise.
fetch(endpoint)
    .then(blob => blob.json())
    .then(data => cities.push(...data));
```

### keyup 

```
function displayMatches() {
    console.log(this.value); 
}

const searchInput = document.querySelector('.search');
const suggestions = document.querySelector('.suggestions');

searchInput.addEventListener('change', displayMatches);
// for a change event you have to click outside the box, we can add a keyup event to refresh on each key you type
searchInput.addEventListener('keyup', displayMatches);
```

### displayMatches 
We call this function using an event listener on the `.search` input form. Thus the value of `this.value` is equal to whatever we typed, lets say "Bos" for the rest of this example.  We call findMatches on the cities data object to filter it to down.  We then create the html to display the results using map and join to coalesce it into one string.  In our `map` callback function we define a new RegExp object equivalent to what we typed, then in each "place object" we replace to the regular expression characters with a span with a class of highlight.  Finally we return our formatted using template literals to call the variables we created.  

```
function displayMatches() {
    console.log(this.value); // shows the typed value if we call it on the .search form 
    const matches = findMatches(this.value, cities); 
    console.log(matches);
    
    const html = matches.map(place => {
        const regex = new RegExp(this.value, 'gi');
        const cityName = place.city.replace(regex, `<span class='hl'>${this.value}</span>`);
        const stateName = place.state.replace(regex, `<span class='hl'>${this.value}</span>`);
        
        return `
            <li>
                <span class='name'>${cityName}, ${stateName}</span>
                <span class='population'>${numberWithCommas(place.population)}</span>
            </li>
               `
    }).join(''); //returns an array and we want a string 
    suggestions.innerHTML = html; // set the inner html of the suggestions object to the new html string
}
```

<hr>

## HTML5 Canvas 
Really good tutorial <a href='https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes' target='_blank'>here</a>

With canvas we have a `canvas` html element.  On this we draw on the "context". We select this by calling and selecting either 2d or 3d context. 
```
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');
```

We can set the height and width of the canvas using JS 
```
canvas.height = window.innerHeight;
canvas.width = window.innerWidth;
```

Next we can set the color using `strokeStyle` - this can also be set to a gradient or a pattern. 'lineJoin = round' creates a rounded edge rather than a 90 degree one when two lines meet.  `lineCap = 'round'` adds a rounded semi-circle to the end of a line.  

```
ctx.strokeStyle = '#  BADA55';
ctx.lineJoin = 'round';
ctx.lineCap = 'round';
```

We can draw a line by using `beginPath()` to initialize it, calling `moveTo` to move the context somewhere, then call `LineTo` to draw a line from the "moveTo" coordinate arguments to the "lineTo" coordinate arguments.  `stroke` actually draws it.  

```
ctx.beginPath();
ctx.moveTo(lastX, lastY);
ctx.lineTo(e.offsetX, e.offsetY);
ctx.stroke();
```

### HSL
<a href='http://mothereffinghsl.com/' target='_blank'>Mother effing HSL</a>
  
This is an <a href='http://www.useragentman.com/blog/2010/08/28/coding-colors-easily-using-css3-hsl-notation/' target='_blank'>awesome hsl tutorial</a>

  
+ Hue: Color from 0 to 360. 
    + Red: 0, Yellow: 60, Green: 120, Cyan: 180, Blue: 240, Magenta: 300, Red: 360
+ Saturation: How "colorful" something is from 0% to 100%
    + 0% is essentially grey, 50% is pretty muted, and 100% is vibrant / neon.
+ Lightness: how light something is from 0 to 100% 
    + 0% is black, 100% is white, 50% is relatively normal.
+ some browsers also support hsla where the fourth argument "alpha" is essentially transparency

### Event Listeners 
Here we use a flag with 4 event listeners.  We listen for a mousedown event, when this occur we set our flag to true, which will trigger the mousemove event.  Our final two event listeners listen for the two negation events, mouseup and mouseout.

```
canvas.addEventListener('mousedown', (e) => {
  isDrawing = true;
  [lastX, lastY] = [e.offsetX, e.offsetY];
});
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', () => isDrawing = false);
canvas.addEventListener('mouseout', () => isDrawing = false);// need this
```

<hr>


## 14 Dev Tricks 

### Find hidden JS
You know when an element is changing but can't figure out how.  Inspect and select the element you're curious about, right-click it and select Break On --> attribute modifications.  It will open a debugger and show us the line of code that is modifying this element's attributes.  

In this example we would do this on the paragraph element

```
<!DOCTYPE html>
<html>
<head>
    <title>Dev Tricks</title>
</head>
<body>
    <p onClick='makeGreen()'>Paragraph text</p> <!-- This is the same as adding an event listener -->
</body>
<script>
    console.log('hello');
    
    function makeGreen() {
        const p = document.querySelector('p');
        p.style.color = '#BADA55'; 
        p.style.fontSize = '50px';
    }
</script>
</html>
```

### Interpolate 
We can interpolate values into `console.log` using `%` notation.  This is basically the same as backticks but it's useful to know the syntax. 
```
const str = 'string';
console.log('hello I am a %s value.', str);
console.log(`hello I am a ${str} value.`);
```

### Style console.log
We can style console.log messages using the following syntax: 
```
    console.log('%c hello I am some text.', 'font-size: 50px; background-color: red; text-shadow: 10px 10px 0 blue;')
```

### Error messages / Testing 
Some useful code for test-driven development 

```
// warnings
console.warn('oh no!!!');

// errors 
console.error('shit!'); 

// info
console.info('crocodiles eat 3 people per year');

// Testing 
// evaluates if T/F and prints the message if false 
console.assert(1===1, 'That is wrong!');
console.assert(1===2, 'That is wrong!')
// More useful example of this 
const p = document.querySelector('p');
console.assert(p.classList.contains('ouch'), 'Does not contain class "ouch"');

// Clearing 
console.clear()
```

### Viewing DOM elements 
We can use `console.dir()` to show all the methods, classes, etc. that live on a DOM element 
```
const p = document.querySelector('.p');
console.dir(p);
```

### Grouping 
If we have lots of debugging information we can group information together using a set of variables or names.  This creates separate drop down menus with the information we want - that can be displayed collapsed or uncollapsed by default.  

```
// Grouping together 
const dogs = [{name: 'Clifford', age: 2}, {name: 'Rusty', age: 4}];
dogs.forEach(dog => {
console.groupCollapsed(`${dog.name}`);
console.log(`This is ${dog.name}`);
console.log(`${dog.name} is ${dog.age} years old`);
console.log('more error messages!');
console.groupEnd(`${dog.name}`);
})
```

### Count 
`console.count` counts how many times an object appears 

```
// count 
// count how many times something appears 
console.count('Dom');
console.count('Dom');
console.count('Dom');
console.count('hi');
console.count('Dom');
```

### Timing 
We can wrap a code block in `console.time('name')` and `console.timeEnd('name')` to see how long that code took to execute. 

```
console.time('fetching data');
fetch('https://rickandmortyapi.com/api/character/')
.then(data => data.json())
.then(data => {
console.log(data);
console.timeEnd('fetching data');
});
```

### Table 
`console.table` outputs a data array in pretty-printed table format 
```
// table
const dogs = [{name: 'Clifford', age: 2}, {name: 'Rusty', age: 4}];
console.table(dogs);
```

<hr>

## Hold Shift to check Boxes 

### Style a checkbox 
In this example we used the `:checked` psuedoclass and a `+ p` to apply it to the nearest paragraph element. `text-decoration: line-through;` adds a through-line to the paragraph element
```
input:checked + p {
background: #F9F9F9;
text-decoration: line-through;
}
```

### Style a list 
The following code styles a list nicely, it adds lines beneath each listen item except for the last one. In this example we have a checkbox input followed by a p.  Here we add a border-left on the p element to creates a nice grid effect. 

```
.item {
  border-bottom: 1px solid #F1F1F1;
}

.item:last-child {
  border-bottom: 0;
}

p {
  border-left: 1px solid #D1E2FF;
}
```

### Comparisons on DOM elements 
The big takeaway from this project is that we can perform copmarisons on DOM elements.  

### Summary 
We create a listen with X amount of inputs with `type='checkbox'`.  Next we select all of them and add an event listener to each one.  We listen for a click event.  On every click event our callback function updates the variable `lastChecked` which stores a copy of the DOM element that we last checked.  In the callback function we then add an if block that asserts that the event `shiftKey` property and `this.checked` are both true.  If this is the case we then loop over each input element.  This is the clever part: we add a flag called `inBetween` that we want to set to `true` when we are between the two checked boxes.  We initialize it to `false` and set it to its opposite value `!inBetween` if the current element we're looping over is equal to either `this` (the input that triggered the event) or `lastChecked` (the input we checked before this one).  To do this we can just directly compare the current iteration input, in this case `checkBox` to both directly using `if (checkBox === this || checkBox === lastChecked)`.  Once we have the flag logic then we just update each element we're iterating over if the flag is true.  

### Code Snippets 

+ `margin: 50px auto;` Adds 50px top and bottom and evenly spaces pixels on the left and right - useful for centering an item.



## HTML Video Player 

### Styling a button 
We can style a button many different ways.  This example primarily uses `background: none` to remove the white background, `border: 0` to remove the 1 px border, and `color: white` to change the play button to white rather than black.

```
.player__button {
  background: none;
  border: 0;
  line-height: 1;
  color: white;
  text-align: center;
  outline: 0;
  padding: 0;
  cursor: pointer;
  max-width: 50px;
}
```

### cursor: 
The cursor property sets what the mouse cursor looks like when it hovers over an element.  Here I set it to `cursor: crosshair` just to hammer home what it does - since setting it to `cursor: pointer` is what I have by default anyway.  

### focus psuedoclass
The `:focus` psuedoclass is applied when an element is selected either by clicking on it or when a user tabs over to it.  With this we can set `outline: none` to remove the blue glow when an element is selected.  This is a key accessibility feature so if you remove it something else needs to happen on :focus.  

```
.player__button:focus {
    /*border: 5px solid red;*/
    border: 1px solid #ffc600;
    outline: none;
}
```

### linear-gradient
We can do some creative things with linear gradient.  This iteration specifies an angle of 135 degrees for the gradient to go through (which is more or less top left corner to bottom right), then it defines 3 stopping points at percentages. 

+ 90deg is left to right 
+ 180deg is top to bottom
+ 270 deg is right to left 
+ 360 deg is bottom to top

https://medium.com/@patrickbrosset/do-you-really-understand-css-linear-gradients-631d9a895caf

```
linear-gradient(135deg, #7c1599 0%,#921099 48%,#7e4ae8 100%)
```

### Use a psuedoclass to modify another class 
We can use psuedoclasses to modify other elements using the following syntax. Here when we hover over the element with class "player" we modify the underlying CSS for elements with the "player__controls" class. 

```
.player:hover .player__controls{
    transform: translateY(0) translateY(-10px);
}
```

## Slide in on scroll 

### float:left 
To get text to wrap around an element (in this case an `img`) we can set its `float` property.  This will cause elements like text to flow past it.

### figure and figcaption
In HTML5 we can use the `figure` tag to wrap an `img` or other element. Inside there we can also use the `figcaption` element to add a caption. 
```
<figure>
  <img src="pic_trulli.jpg" alt="Trulli" style="width:100%">
  <figcaption>Fig.1 - Trulli, Puglia, Italy.</figcaption>
</figure>
```

### debounce 
If we want to limit the rate at which a function is called.  For instance a callback function on a scroll event - we use a technique called debouncing.  This essentially limits how many times we can call a function in a certain time period.  We pass in a function - and specify how long in milliseconds we wait until it can be called again.

```
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate) {
	var timeout;
	return function() {
		var context = this, args = arguments;
		var later = function() {
			timeout = null;
			if (!immediate) func.apply(context, args);
		};
		var callNow = immediate && !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	};
};
```

### scrollY
The window object has a property called `scrollY` that shows where you are in the page based on it's Y-dimension.  
```
window.scrollY
```

### Y property 
I think this property is initially positive for a DOM element, then when you scroll down it moves toward 0 - its 0 point is where the top of the DOM element is at the top of the scroll window.  Then it becomes negative.  

### offSetTop
Property of DOM elements that tells you how many px from the top of the page the beginning of an element is 

### Summary
Waiting on this until I do the project again. 

<hr>

## Key Sequence 

### splice 
If we pass a negative argument into the `splice` methods first argument it will start from the back.  Remember that the first one is not included so we add another -1 when using this method.  If we pass a negative number or zero into splices second argument ("deleteCount") nothing will happen.  So on an array with 6 entries - calling splice with a negative second argument just reutrns an empty vector. This is useful if we want to dynamically check and only splice when it's positive. Interesting if we tell it to start splicing from an element further back than the initial entry (for example -7 would correspond to the index before 0, -10 to the -3 index etc.). It will still start splicing at 0 as if there wasn't an error. 

```
let arr = [1, 2, 3, 4, 5, 6]
arr.splice(-7, 0);
arr.splice(-7, -5);
arr.splice(-10, 1);
arr.splice(-1000, 1)'
```

## Reference vs. Copy 
For integers, characters, and booleans we can use the `=` sign to create a copy of something.  However if we use the `=` operator for arrays or objects it creates a pointer.  If we want to create copies of objects or arrays we need to use other methods of doing so, otherwise any changes will change the original as the second is just a pointer to the first one.  There are some examples of what is valid and invalide below:

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
</head>
<body>

  <script>
    // start with strings, numbers and booleans
    let age = 100;
    let age2 = age;
    console.log(age, age2); // 100 100
    age = 200; 
    console.log(age, age2); // 200 100
    // The value gets stored in the new variable - not a pointer to the first variable, so updating the first one won't change the second.
      
    // Let's say we have an array
    const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

    // and we want to make a copy of it.
 /*   const team = players; 
    console.log(players, team); // they're the same 
      
    // You might think we can just do something like this:
    team[3] = 'Lux';
    console.log(players); */
    // We updated team -> team is just a reference to the original players array 
    // When you use '=' syntax it creates a REFERENCE rather than a copy

    // Why? It's because that is an array reference, not an array copy. They both point to the same array!

    // So, how do we fix this? We take a copy instead!

    // one way
    // Use slice()
    const team2 = players.slice();
    team2[3] = 'lux';
    console.log(team2. players);
    

    // or create a new array and concat the old one in
    const team3 = [].concat(players); 
      
    // or use the new ES6 Spread
    const team4 = [...players];
      
    // or use Array.from()
    const team5 = Array.from(players);

    // now when we update it, the original one isn't changed

    // The same thing goes for objects, let's say we have a person object

    // with Objects
    const person = {
      name: 'Wes Bos',
      age: 80
    };

    // and think we make a copy:
    const captain = person;
    captain.age = 99;
    console.log(person.age);

    // how do we take a copy instead?
    const captain2 = Object.assign({}, person, {age: 99})
    // take a blank object, second arg is the object we want a copy of, then we can optionally overwrite or add properties with the third argument.

    // We will hopefully soon see the object ...spread
 /*   const cap3 = {...person};
    console.log(cap3);*/

    // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
    const wes = {
        name: 'Wes',
        age: 100, 
        social: {
            twitter: '@wesbos',
            facebook: 'wesbos.developer'
        }
    }
    console.clear();
    console.log(wes);
    
/*    const wes2 = Object.assign({}, wes, {age:25});
    console.log(wes2);
      
    // Here are the references 
    wes2.social.twitter = '@coolguy'; 
    console.log(wes.social.twitter);*/
    
    // It only makes copies for the first level then uses references for the subsequent ones
      
    // JSON hack 
    const dev3 = JSON.parse(JSON.stringify(wes));
    dev3.social.twitter = '@coolguy';
    console.log(wes.social.twitter);

  </script>

</body>
</html>
```

<hr>

## Local Storage and Event Delegation

### Event Delegation 
As an event bubbles up it can trigger on multiple elements. Especially if we have an event listener on a parent DOM element.  In these situations we can use event delegation - we listen for the event we want and add logic in the callback function that only triggers the function body on the DOM elements we want.  Example: 

```
function toggleDone(e) {
    // console.log(e.target);
    // Event delegation
    if (!e.target.matches('input')) return; // skip unless it's an input
    let index = e.target.dataset.index;
    console.log(index);
    items[index].done = !items[index.done];
    localStorage.setItem('items', JSON.stringify(items));
}
```

### Change svg color
To change the color of an svg element we use the `fill` style property. Here is an example with some other valid formatting applied to it. 

```
svg {
    height: 250px;
    width: 250px;
    background: rgba(0, 0, 0, .2);
    border-radius: 50%;
    border: 20px solid rgba(0, 0, 0, 0);
    fill: white;
}}
```

### input style 
For some input styles it's necessary to override the default browser settings.  For instance you can't update padding without removing browser defaults.  Here's an example 

```
input[type='submit'] {
    padding: 10px;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
}
```

### event.target

### Local Storage 
We can access local storage using `window.localStorage`.  There are 5 methods to choose from using localStorage 

+ setItem(): Add key and value to LocalStorage
+ getItem(): Retrieve a value by the key from LocalStorage
+ removeItem(): Remove an item by key from LocalStorage
+ clear(): Clear all LocalStorage
+ key(): Passed a number to retrieve nth key of a LocalStorage

To store arrays or objects you would have to convert them to strings. To do this we use the JSON.stringify() method before passing to setItem() .

```
const person = {
    name: "Obaseki Nosa",
    location: "Lagos",
}
window.localStorage.setItem('user', JSON.stringify(person));
```

#### Limitations 
Do not store sensitive user information in localStorage. 
It is not a substitute for a server based database as information is only stored on the browser. LocalStorage is limited to 5MB across all major browsers.
LocalStorage is quite insecure as it has no form of data protection and can be accessed by any code on your web page.
LocalStorage is synchronous. Meaning each operation called would only execute one after the other.

### e.preventDefault();
When working with a `submit` event it will refresh the page by default on most major browsers.  In the callback function if we call `    e.preventDefault();` it will prevent the default behavior and stop the page from re-loading.  This is useful for when we are writing the callback function and want to work with the local objects before they are removed by the refresh.  

### Preserve Log
If we check the Settings -> `preserve log` option in devtools it will preserve the log on a pageload and show you the source of a new page load.  This is useful when working with `submit` events that trigger this by default.

### Call querySelector on this
If we have multiple input forms it's a good idea to use the `this` object and `querySelector` to select the one being targetd by an event listener.
```
const text = this.querySelector('[name="item"]');
```

### form.reset()
Form DOM elements have a method called `reset` that reverts it back to its placeholder value.  We usually call it by using `this.reset()` when using a callback function with an event listener.


<hr>


## Text Shadow on mouse move

### contenteditable
The contenteditable global attribute is an enumerated attribute indicating if the element should be editable by the user. If so, the browser modifies its widget to allow editing.
```
<h1 contenteditable>😱 WOAHHHH!!</h1>
```

### ClientX, ScreenX, and PageX
pageX and pageY:
Relative to the top left of the fully rendered content area in the browser. This reference point is below the URL bar and back button in the upper left. This point could be anywhere in the browser window and can actually change location if there are embedded scrollable pages embedded within pages and the user moves a scrollbar.

screenX and screenY:
Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.

clientX and clientY:
Relative to the upper left edge of the content area (the viewport) of the browser window. This point does not move even if the user moves a scrollbar from within the browser.

### destructuring 
Example of destructuring two `const` variables 
```
const hero = document.querySelector('.hero');
const {offsetWidth: width, offsetHeight: height} = hero;
```

### mousemove with children 
If we add a mousemove event listener on a parent element, then it's possible that `e.target` can change if we hover any of the children of the parent.  In this example we have the `.hero` div with h1 text inside of it.  If we hover over the h1 element we see that event.target changed, even though `this` is still equal to `.hero` because that's where we added the event listener.

```
const hero = document.querySelector('.hero');
const text = hero.querySelector('h1');

function shadow(e) {
    // console.log(e);
    const {offsetWidth: width, offsetHeight: height} = hero;
    let {offsetX: x, offsetY: y} = e;
    //console.log(x, y);
    
    // console.log(this, e.target); // we can see that this is usually the hero div, but if we hover over h1 that becomes the target
    if (this !== e.target) {
        x = x + e.target.offsetLeft;
        y = y + e.target.offsetTop;
    }
}

hero.addEventListener('mousemove', shadow);
```

### offsetLeft, offsetTop
DOM elements have the 4 properties offSetLeft, Top, right, and bottom. These come in handy.  


<hr> 

## Sort with articles 

### list-style: inside square
Using `list-style: inside square` on a list element changes the round bullets to square ones and puts the bullet element inside the `<li>` item.  This is really useful if you want to underline the entire `<li>` element.  If you don't do this then the bullet lives in the padding and you can't underline it.  Calling `list-style: inside` is sufficient to create this effect. 

```
ul {
    list-style: inside square;
    padding: 0;
    width: 40vw;
    background: rgba(255, 255, 255, .7);
    box-shadow: 0 0 0 10px rgba(0, 0, 0, .1); 
}
```

### Sort with articles 
The logic here uses arr.sort() which places an element below one if the result of a < b is negative.  We need the ternary there to make that logic work for characters.  Next, in the actual a < b comparison we want to exclude the articles.  For this we create a function called `removeArticles` and wrap a and b in it.  In this function we create an array of all the articles we want to exclude, wrapped in parentheses (regex group syntax), next we join then on '|' and create a new `RegExp` object so that we can pass that into the `string.replace` method.  Finally we call replace with the RegExp object, trim() any extra whitespace, and use `replace(/\s\s+/g, ' ')` to remove any instance of extra whitespace. 

```
const bands = ['The Plot in You', 'The Devil Wears Prada', 'Pierce the Veil', 'Norma Jean', 'The Bled', 'Say Anything', 'The Midway State', 'We Came as Romans', 'Counterparts', 'Oh, Sleeper', 'A Skylit Drive', 'Anywhere But Here', 'An Old Dog'];

function removeArticles(input) {
    const articles = ['(the)', '(a )', '(in )', '(as )', '(an )', '(and )', '(, )'];
    const regex = new RegExp(articles.join('|'), 'gi');
    return input.replace(regex, ' ').
                                    trim().
                                    replace(/\s\s+/g, ' ');
}

bands.sort((firstBand, secondBand) => {
    return removeArticles(firstBand) < removeArticles(secondBand) ? -1 : 1; 
})
```

## Reduce 

Sum up a bunch of elements with time attributes that look like this:

```
<li data-time="5:43">
      Video 1
    </li>
    <li data-time="2:33">
```

### querySelectorAll 
We can use querySelectorAll to return all DOM elements that have an existing attribute. In this example we return all DOM elements that have a `data-time` attribute. 
```
  const timeNodes = document.querySelectorAll('[data-time]')
```

### Callback function only 
When using a callback function we have the option of using the following syntax. This will call `parseFloat` on "6" and "10" separately.

```
"6.10".split(':').map(parseFloat)
```

<hr> 

##Webcam

### webcam syntax 
The following syntax returns a video from the webcam.  A dialogue box asking permission appears.  The `getUserMedia` function returns a promise that then returns a local media stream.  We handle this media stream by setting it to the `video.src` property of the `video` element and calling `video.play()`

```
function getVideo() {
    // returns a promise
    navigator.mediaDevices.getUserMedia({video: true, audio: false})
        .then(localMediaStream => {
        //console.log(localMediaStream);
        // deprecated on chrome 
        // video.src = window.URL.createObjectURL(localMediaStream);
        video.srcObject = localMediaStream;
        video.play();
    })
    .catch(error => {
        console.log(error);
    });
}
```

### takePhoto, document.createElement
`canvas.toDataURL('image/jpeg')` changes the canvas to base 64 text data.  If we console log it we see it's just text. Next we create a link element `a` with `document.createElement`.  We set it's `href` attribute to the base 64 data object, `setAttribute('download', 'handsome')` sets the name when we download it, and `link.textContent = 'Download Image';` sets the name of the anchor element. Finally we call `.insertBefore` to put the anchor element above the strip div. 


```
function takePhoto() {
    snap.currentTime = 0;
    snap.play();
    
    // take the data out of the canvas
    const data = canvas.toDataURL('image/jpeg');
    console.log(data); //base 64 data 
    const link = document.createElement('a');
    link.href = data;
    link.setAttribute('download', 'handsome');
    link.textContent = 'Download Image';
    strip.insertBefore(link, strip.firstChild);
}
```

### getImageData 
`getImageData` returns the pixels from a canvas context. It returns them in the form: 0: 201 = red pixels, 1: 243 = green pixel, etc.  It's usually millions of lines long. 

```
let pixels = ctx.getImageData(0, 0, width, height); // returns pixels in a large array of red, green, blue, alpha - repeating
```


## Speech Recognition

## GeoLocation

## Speech Synthesis 

### <select> dropdown
The following code creates a "select" dropdown menu

```
<select id="pet-select">
            <option value="">--Please choose an option--</option>
            <option value="dog">Dog</option>
            <option value="cat">Cat</option>
            <option value="hamster">Hamster</option>
            <option value="parrot">Parrot</option>
            <option value="spider">Spider</option>
            <option value="goldfish">Goldfish</option>
        </select>
```

### radial-gradient


Example of creating a repeating semi-circle background pattern

```
background-image:
    radial-gradient(circle at 100% 150%, #3BC1AC 24%, #42D2BB 25%, #42D2BB 28%, #3BC1AC 29%, #3BC1AC 36%, #42D2BB 36%, #42D2BB 40%, transparent 40%, transparent),
    radial-gradient(circle at 0    150%, #3BC1AC 24%, #42D2BB 25%, #42D2BB 28%, #3BC1AC 29%, #3BC1AC 36%, #42D2BB 36%, #42D2BB 40%, transparent 40%, transparent),
    radial-gradient(circle at 50%  100%, #42D2BB 10%, #3BC1AC 11%, #3BC1AC 23%, #42D2BB 24%, #42D2BB 30%, #3BC1AC 31%, #3BC1AC 43%, #42D2BB 44%, #42D2BB 50%, #3BC1AC 51%, #3BC1AC 63%, #42D2BB 64%, #42D2BB 71%, transparent 71%, transparent),
    radial-gradient(circle at 100% 50%, #42D2BB 5%, #3BC1AC 6%, #3BC1AC 15%, #42D2BB 16%, #42D2BB 20%, #3BC1AC 21%, #3BC1AC 30%, #42D2BB 31%, #42D2BB 35%, #3BC1AC 36%, #3BC1AC 45%, #42D2BB 46%, #42D2BB 49%, transparent 50%, transparent),
    radial-gradient(circle at 0    50%, #42D2BB 5%, #3BC1AC 6%, #3BC1AC 15%, #42D2BB 16%, #42D2BB 20%, #3BC1AC 21%, #3BC1AC 30%, #42D2BB 31%, #42D2BB 35%, #3BC1AC 36%, #3BC1AC 45%, #42D2BB 46%, #42D2BB 49%, transparent 50%, transparent);
    background-size:100px 50px;
```

### Web Speech API
The Web Speech API makes web apps able to handle voice data. There are two components to this API:

Speech recognition is accessed via the SpeechRecognition interface, which provides the ability to recognize voice context from an audio input (normally via the device's default speech recognition service) and respond appropriately. Generally you'll use the interface's constructor to create a new SpeechRecognition object, which has a number of event handlers available for detecting when speech is input through the device's microphone. The SpeechGrammar interface represents a container for a particular set of grammar that your app should recognise. Grammar is defined using JSpeech Grammar Format (JSGF.)
Speech synthesis is accessed via the SpeechSynthesis interface, a text-to-speech component that allows programs to read out their text content (normally via the device's default speech synthesiser.) Different voice types are represented by SpeechSynthesisVoice objects, and different parts of text that you want to be spoken are represented by SpeechSynthesisUtterance objects. You can get these spoken by passing them to the SpeechSynthesis.speak() method

### window.speechSynthesis 
We use this to define a new synthesis object with `const synth = window.speechSynthesis`. This object has 4 basic properties:, onvoiceschanged: null, paused: false, pending: false, speaking: false.

### speechSynthesis.getVoices()
Returns an array of all available voices. They have the following format / properties. 

```
SpeechSynthesisVoice
default: true
lang: "en-US"
localService: true
name: "Alex"
voiceURI: "Alex"
```

### Load function on page load 
The only method I could to work was `setTimeOut`.  I'm not sure if this is because my function depends on the `const synth` variable already being created or not. 

```
// this was the only way I could get it to work. The following two methods didn't work
// <body onload='populateVoiceSelect()'>
// document.addEventListener('DOMContentLoaded', populateVoiceSelect);
setTimeout(populateVoiceSelect, 20);
```