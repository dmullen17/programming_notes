#JS30 
These are my notes from Wes Bos's free Javscript 30 [course](https://javascript30.com/)

## Drumkit 

### Center div within div 
We need to add text-align: center to the parent div to center text horizontally.  Then in the child div elements we add top 50% and position relative to center them vertically.  

```
.parent-div {
  text-align: center;
}

.child-div {
  top: 50%; 
  position: relative; 
}
```

### document.querySelectorAll
**Add a class to a div on keypress:**
This method returns a NodeList element so it's necessary to use indexing to find the one we want.  This is usually [0] if we're using data attributes to search. Here we use querySelectorAll method to find the div where we set the data attribute `data-key` equal to the `event.keyCode`

```{html, javascript}
<!DOCTYPE html>
<html>
<div class='key' id='key-1' data-key='65'><h2>A</h2><p class='key-p'>CLAP</p></div>
<script> 
window.addEventListener('keypress', function(event){
    console.log(event.keyCode);
    document.querySelectorAll(`[data-key='${event.keyCode}']`)[0].classList.add('key-press');
</script>
</html>
```

### Event Bubbling
When an event is triggered it will "bubble" up through its parent elements until it reaches the window. If it reaches any event handlers those will process if they match the event.  When we have multiple children we typically add an event handler to their parent element so we only need to write the code once. 

+ Example of event bubbling 

```{html}
<!DOCTYPE html>
<html>
    <head>
        <style type='text/css'>  
            .styling {
                display: table-cell;
                border: 1px solid black; 
                padding: 20px; 
                text-align: center; 
            }
        </style>
    </head>
    <body>
        <div class='styling' onclick='alert("DIV CLICKED")'>Div element
            <span class='styling' onclick='alert("Span clicked")'>Span element
                <input type='button' class='styling' value='Click me!' onclick='alert("button clicked")'>
            </span>
        </div>
    </body>
</html>
```

#### 'this' in event bubbling
`this` refers to the current element to which the event is bubbled. 

+ Example using `this` in event bubbling.  Not a great example because of the for loop.  

```
<!DOCTYPE html>
<html>
    <head>
        <style type='text/css'>  
            .styling {
                display: table-cell;
                border: 1px solid black; 
                padding: 20px; 
                text-align: center; 
            }
        </style>
    </head>
    <body>
        <div id='div1' class='styling' onclick="changeBorder()">div1
            <div id='div2' class='styling' onclick ="changeBorder()">div2
                <div id='div3' class='styling'>div3</div>
            </div>
        </div>
    </body>
    <script>
        let divElements = document.getElementsByTagName('div');
        for (let i =0; i < divElements.length; i++) {
            divElements[i].onclick = function() {
                this.style.border = '3px solid pink';
                alert(this.getAttribute('id') + 'color changed');
            };
        }
        
    </script>
</html>
```

#### Stop event bubbling
In IE8 and earlier versions we use `event.cancelBubble = true`, with all other browsers we use `event.stopPropogation()`

### Transition end event 
Similar to a click event - when an element transitions it fires off a transition end event that says "I'm finished transitioning".  In this case elements are scaling up by 1.1 and making the border larger.  Each CSS property that transitions records its own event (there will likely be lots of transition events in adding / removing a class).

+ In this example: this is always equal to what got called against it - in this case "addEventListener" was called against key --> so this = key

```
const keys = document.querySelectorAll('.key');
// loop over the NodeList to add event listeners
keys.forEach(key => key.addEventListener('transitionend', removeTransition));

function removeTransition(e) {
    console.log(e); 
    // this shows a ton of events - one for each property
    if (e.propertyName !== 'transform') return; // skip the event 
    console.log(this); // see what this is 
    // this is always equal to what got called against it - in this case "addEventListener" was called against key --> so this = key.
};
```

<hr>

## JS Clock

### Center div using translate
The translate() CSS function repositions an element in the horizontal and/or vertical directions. In this example we transform it by subtracting 50% of it's width from the X-direction.  Thus - left: 50% and transform(-50%) center it horizontally.  The same is true vertically.  

```{html}
<!DOCTYPE html>
<html>
    <head>
        <style>
            .centered-div {
                background-color: black;
                position: absolute;
                height: 500px;
                width: 350px;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
        </style>
    </head>
    <body>
        <div class='centered-div'></div>
    </body>
</html>
```

### Center div using flexbox

```
body {
    display: flex;
    min-height: 100vh;
    align-items: center;
}

.clock {
    margin: auto;
}
```

### box shadow

+ `0 0 0 4px rgba(0,0,0,0.1)` - applies an outer shadow to our clock face 
+ the next one has `inset` which applies it on the inside of the clock diameter
+ 

```
box-shadow:
0 0 0 4px rgba(0,0,0,0.1),
inset 0 0 0 3px #EFEFEF,
inset 0 0 10px black,
0 0 10px rgba(0,0,0,0.2);
```

### position: relative 
We need a div with relative position to place our hand divs.  These three will be absolutely positioned (i.e. stacked on top of each other).  This is necessary so they all rotate from the origin

### Setup Description 
The background is standard.  We turn `body` into a flex container with min-height: 100vw and `align-items` and `justify-content` set to center to get the clock in the middle of the flex container.  The clock div we style.  Inside the clock div we create another with 100% height and width with positition set to relative - this is so we can use absolute positioning on the clock hands divs.  For clock hands we set their height, width, and background to create the slim rectangle, next we set top to 50% to move it to the center of the div.  Finally we set the position to absolute to stack them on top of each other.  

```
html {
    background: #018DED url(http://unsplash.it/1500/1000?image=881&blur=50);
    background-size: cover;
    font-family: 'helvetica nue';
    font-size: 10px;
}

body {
    display: flex;
    flex: 1;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
}

.clock {
    height: 30em;
    width: 30em;
    border: 20px solid white;
    border-radius: 50%;
    box-shadow: 0 0 0 4px rgba(0, 0, 0, .1),
        inset 0 0 0 3px #EFEFEF,
        inset 0 0 10px black,
        0 0 10px rgba(0,0,0,0.2);
}

.clock-face {
    height: 100%; 
    width: 100%; 
    position: relative;
    transform: translateY(-3px); /*accounts for half the height of the clock hands */
}

.hand {
    background: black;
    height: 6px;
    width: 50%;
    position: absolute;
    top: 50%;
}
```

### transform-origin
Updates where the origin is in an element.  The default is 50%.  Changing it to 100% makes the origin the right most side of the X-axis.
```
transform-origin: 100%;
```

### transition timing 
Another way to set transition timing 
```
transition: all .05s;
transition-timing-function: all cubic-bezier(.1, 2.7, .65, 1);
```

### JS Logic 
The logic here is fairly simple.  We run a function `setDate` every one second.  Each second we create a new Date object that has methods for extracting the current second, minute, and hour.  We update the CSS of each of the three hand div elements based on the current sec, min, hour, converted into degrees.  We update the `transform: rotate(xdeg);` property of each of them.  We add a cubic-bezier timing that creates a tic effect to these `transition` events.  

```
function setDate() {
    // console.log('hi');
    const now = new Date();
    const seconds = now.getSeconds();
    const secondsDegrees = (seconds/60)*360 + 90;
    //console.log(secondsDegrees);
    if (secondsDegrees == 90) secondHand.style.transition = '0s';
    // console.log(seconds);
    secondHand.style.transform = `rotate(${secondsDegrees}deg)`;
    
    const minutes = now.getMinutes();
    const minutesDegrees = (minutes/60)*360 + 90;
    if (minutesDegrees == 90) secondHand.style.transition = '0s';
    minHand.style.transform = `rotate(${minutesDegrees}deg)`;
    
    const hours = now.getHours();
    // console.log(hours); - base 24
    const hoursDegrees = (hours/12)*360 + 90;
    if (hoursDegrees == 90) secondHand.style.transition = '0s';
    hourHand.style.transform = `rotate(${hoursDegrees}deg)`;
}
```

<hr>

## CSS Variables 

### slider input 
The following code generates a slider input button. We can also set `min` and `max` attributse on the slider. 
```
<input type='range' min='10' max='200' value='10'>
```

### Access data attributes 
We can access data attributes using an event listener.  Upon an event we can console log: `this.dataset`.  This will return a data object of all properties that are prefixed with the `data-` attribute.  
```
<input type='range' min='0' max='100' value='50' data-sizing='px'>
<script>
const input = document.querySelector('input'); 
input.addEventListener('change', function(event) {
  console.log(this.dataset);
})
</script>
```

## Array Cardio 1 

### sort
The `sort` method sorts an array based on the values the callback function calculates.  If we use (a, b) => return a - b, and the first two elements of an array are 40 and 100, then it will return -60, a negative value, so it will sort 40 lower than 100.


### reduce
The first two input values to reduce are to total and currentValue. I was thinking of it too often as index elements 0 and 1, then 0+1, and 2, etc.  The first iteration of this is actually the unitialized variable "total" and index element 0.  We here set the initial value of total to zero.  
```
const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];
    let numCars6 = data.reduce((total, currentValue) => total + (currentValue === 'car' ? 1 : 0), initialValue = 0);
```
We can also use an object as a way to keep track of multiple fields when using reduce instead of an integer. Here we set the intial value to an empty object, initialize an obj[item] to 0 if it DNE to dynmically populate the object, then increment the count.
```
const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];
let counts = data.reduce(function(obj, item) {
  if (!obj[item]) {
    obj[item] = 0;
  }
  obj[item] ++;
  return obj;
}, {})
```

### console.table
This function outputs objects in a stylized table - makes it really easy to read.  

### map 
Good way to conceptualize map is like a factory machine. It will put a stamp on each item -> or take in X items, do something to them, and return the same amount of items.   

### Turn a NodeList into an Array
We can't use some methods on nodeLists - like map. It's better to turn then into arrays.  We can either wrap a NodeList in `Array.from()`, or enclose it in brackets and use the spread operator. 

<br>

## Flex Panels
This project uses alot of nested flexboxes.  The 5 panels are on flexbox with items centered and content center-justified.  Next the 3 paragraph elements in each panel are a flex grid.  Items are centered and we used flex: 1 to get each of them to take up 1/3 of the space.  Finally each of the paragraph elements are flex boxes with items centered to get the text inside of the paragraphs evenly centered.  

### Combinators 

A CSS selector can contain more than one simple selector. Between the simple selectors, we can include a combinator.

There are four different combinators in CSS3:

descendant selector (space)
child selector (>)
adjacent sibling selector (+)
general sibling selector (~)

This selects all direct child elements of `.panel` and applies margin: 0 to them
```
.panel > * {
    margin: 0;
}
```

### box-shadow
[https://css-tricks.com/almanac/properties/b/box-shadow/](https://css-tricks.com/almanac/properties/b/box-shadow/)
box-shadow: inset 0 0 0 5px rgba(255,255,255,0.1);

### transition 
With the transition property you specify a property, time, and cubic bezier function to specify how a transition animation will play out.  When one of these properties is changed either by a class addition or JS these timing effects will apply.  
```
.panel {
transition:
  font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),
  flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),
  background 0.2s;
}
```

### psuedo-classes
List of psuedo classes: https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes

### flex: 1
```
flex: 1; /* evenly distribute items among space */
```
if we give one of the 12 elements here a `flex:5` then it will takes up 5 times as much space as the other 11 items that have `flex:1`

### Run on pageload
If we have a callback function that's invoked in the event listener then it will run on pageload.  We just want to give a callback function something to reference - which is why we don't immediately invoke it with braces.  Example of immediately invoking an event listener callback function 
```
panels.forEach(panel => panel.addEventListener('click', toggleOpen()));
```

<br>

## Ajax Type Ahead 

### Style input placeholder text 
For this we use a psuedoclass to style the text.  
```
#search-main::placeholder {
    color: red;
}
```

+ `box-sizing: border-box` If we set the width of an element to 300px it will often appear bigger because it's border and padding are added to that.  If we set `box-sizing` to `border-box` then the box will always be 300px wide, regardless of what you change border or padding to.  
+ `*, *:before, *:after {box-sizing: inherit;}` this causes elements to inherit the `box-sizing` property from their parents.  This makes it easier when incorporating a component that doesn't use `border-box` to make the rest of its children inherit the `box-sizing` property that we will set at the top level of the component.  At least that what I understood from this [arcticle](https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/)

### fetch 
fetch function gets a URL endpoint then returns a promise object. We call `.then` to return the blob of data object.  From here we need to convert it to the format that we want.  If we look at the object's prototype in this case we see that there is a `.json()` method we can use.  That returns another promise which we need to call `.then` on to get our data.

```
const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';
    
const cities = []; 
    
const prom = fetch(endpoint);
console.log(prom);
// from that it will return a blob of data 
fetch(endpoint).then(blob => console.log(blob));

fetch(endpoint)
    .then(blob => blob.json())
    .then(data => console.log(data));

// Now we can add the data to our cities const using the spread operator and .push.  We use the spread operator b/c it will be a nested array otherwise.
fetch(endpoint)
    .then(blob => blob.json())
    .then(data => cities.push(...data));
```

### keyup 

```
function displayMatches() {
    console.log(this.value); 
}

const searchInput = document.querySelector('.search');
const suggestions = document.querySelector('.suggestions');

searchInput.addEventListener('change', displayMatches);
// for a change event you have to click outside the box, we can add a keyup event to refresh on each key you type
searchInput.addEventListener('keyup', displayMatches);
```

### displayMatches 
We call this function using an event listener on the `.search` input form. Thus the value of `this.value` is equal to whatever we typed, lets say "Bos" for the rest of this example.  We call findMatches on the cities data object to filter it to down.  We then create the html to display the results using map and join to coalesce it into one string.  In our `map` callback function we define a new RegExp object equivalent to what we typed, then in each "place object" we replace to the regular expression characters with a span with a class of highlight.  Finally we return our formatted using template literals to call the variables we created.  

```
function displayMatches() {
    console.log(this.value); // shows the typed value if we call it on the .search form 
    const matches = findMatches(this.value, cities); 
    console.log(matches);
    
    const html = matches.map(place => {
        const regex = new RegExp(this.value, 'gi');
        const cityName = place.city.replace(regex, `<span class='hl'>${this.value}</span>`);
        const stateName = place.state.replace(regex, `<span class='hl'>${this.value}</span>`);
        
        return `
            <li>
                <span class='name'>${cityName}, ${stateName}</span>
                <span class='population'>${numberWithCommas(place.population)}</span>
            </li>
               `
    }).join(''); //returns an array and we want a string 
    suggestions.innerHTML = html; // set the inner html of the suggestions object to the new html string
}
```

<hr>

## HTML5 Canvas 
Really good tutorial <a href='https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes' target='_blank'>here</a>

With canvas we have a `canvas` html element.  On this we draw on the "context". We select this by calling and selecting either 2d or 3d context. 
```
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');
```

We can set the height and width of the canvas using JS 
```
canvas.height = window.innerHeight;
canvas.width = window.innerWidth;
```

Next we can set the color using `strokeStyle` - this can also be set to a gradient or a pattern. 'lineJoin = round' creates a rounded edge rather than a 90 degree one when two lines meet.  `lineCap = 'round'` adds a rounded semi-circle to the end of a line.  

```
ctx.strokeStyle = '#  BADA55';
ctx.lineJoin = 'round';
ctx.lineCap = 'round';
```

We can draw a line by using `beginPath()` to initialize it, calling `moveTo` to move the context somewhere, then call `LineTo` to draw a line from the "moveTo" coordinate arguments to the "lineTo" coordinate arguments.  `stroke` actually draws it.  

```
ctx.beginPath();
ctx.moveTo(lastX, lastY);
ctx.lineTo(e.offsetX, e.offsetY);
ctx.stroke();
```

### HSL
<a href='http://mothereffinghsl.com/' target='_blank'>Mother effing HSL</a>
  
This is an <a href='http://www.useragentman.com/blog/2010/08/28/coding-colors-easily-using-css3-hsl-notation/' target='_blank'>awesome hsl tutorial</a>

  
+ Hue: Color from 0 to 360. 
    + Red: 0, Yellow: 60, Green: 120, Cyan: 180, Blue: 240, Magenta: 300, Red: 360
+ Saturation: How "colorful" something is from 0% to 100%
    + 0% is essentially grey, 50% is pretty muted, and 100% is vibrant / neon.
+ Lightness: how light something is from 0 to 100% 
    + 0% is black, 100% is white, 50% is relatively normal.
+ some browsers also support hsla where the fourth argument "alpha" is essentially transparency

### Event Listeners 
Here we use a flag with 4 event listeners.  We listen for a mousedown event, when this occur we set our flag to true, which will trigger the mousemove event.  Our final two event listeners listen for the two negation events, mouseup and mouseout.

```
canvas.addEventListener('mousedown', (e) => {
  isDrawing = true;
  [lastX, lastY] = [e.offsetX, e.offsetY];
});
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', () => isDrawing = false);
canvas.addEventListener('mouseout', () => isDrawing = false);// need this
```

<hr>


## 14 Dev Tricks 

### Find hidden JS
You know when an element is changing but can't figure out how.  Inspect and select the element you're curious about, right-click it and select Break On --> attribute modifications.  It will open a debugger and show us the line of code that is modifying this element's attributes.  

In this example we would do this on the paragraph element

```
<!DOCTYPE html>
<html>
<head>
    <title>Dev Tricks</title>
</head>
<body>
    <p onClick='makeGreen()'>Paragraph text</p> <!-- This is the same as adding an event listener -->
</body>
<script>
    console.log('hello');
    
    function makeGreen() {
        const p = document.querySelector('p');
        p.style.color = '#BADA55'; 
        p.style.fontSize = '50px';
    }
</script>
</html>
```

### Interpolate 
We can interpolate values into `console.log` using `%` notation.  This is basically the same as backticks but it's useful to know the syntax. 
```
const str = 'string';
console.log('hello I am a %s value.', str);
console.log(`hello I am a ${str} value.`);
```

### Style console.log
We can style console.log messages using the following syntax: 
```
    console.log('%c hello I am some text.', 'font-size: 50px; background-color: red; text-shadow: 10px 10px 0 blue;')
```

### Error messages / Testing 
Some useful code for test-driven development 

```
// warnings
console.warn('oh no!!!');

// errors 
console.error('shit!'); 

// info
console.info('crocodiles eat 3 people per year');

// Testing 
// evaluates if T/F and prints the message if false 
console.assert(1===1, 'That is wrong!');
console.assert(1===2, 'That is wrong!')
// More useful example of this 
const p = document.querySelector('p');
console.assert(p.classList.contains('ouch'), 'Does not contain class "ouch"');

// Clearing 
console.clear()
```

### Viewing DOM elements 
We can use `console.dir()` to show all the methods, classes, etc. that live on a DOM element 
```
const p = document.querySelector('.p');
console.dir(p);
```

### Grouping 
If we have lots of debugging information we can group information together using a set of variables or names.  This creates separate drop down menus with the information we want - that can be displayed collapsed or uncollapsed by default.  

```
// Grouping together 
const dogs = [{name: 'Clifford', age: 2}, {name: 'Rusty', age: 4}];
dogs.forEach(dog => {
console.groupCollapsed(`${dog.name}`);
console.log(`This is ${dog.name}`);
console.log(`${dog.name} is ${dog.age} years old`);
console.log('more error messages!');
console.groupEnd(`${dog.name}`);
})
```

### Count 
`console.count` counts how many times an object appears 

```
// count 
// count how many times something appears 
console.count('Dom');
console.count('Dom');
console.count('Dom');
console.count('hi');
console.count('Dom');
```

### Timing 
We can wrap a code block in `console.time('name')` and `console.timeEnd('name')` to see how long that code took to execute. 

```
console.time('fetching data');
fetch('https://rickandmortyapi.com/api/character/')
.then(data => data.json())
.then(data => {
console.log(data);
console.timeEnd('fetching data');
});
```

### Table 
`console.table` outputs a data array in pretty-printed table format 
```
// table
const dogs = [{name: 'Clifford', age: 2}, {name: 'Rusty', age: 4}];
console.table(dogs);
```