# JavaScript Algorithms and Data Structures FCC 
These are my notes from the JavaScript Algorithms and Data Structures certification from the<a href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript"> FreeCodeCamp lessons</a>

## ES6 
Arrow function defintion syntax: 
```{javascript}
let printAandB = (a, b) => {
  console.log(`${a} = a and ${b} = b`);
}
```

### Destructuring objects 
We can use destructing to assign variables as well. 
```
var voxel = {x: 3.6, y: 7.4, z: 6.54 };
var x = voxel.x; // x = 3.6
var y = voxel.y; // y = 7.4
var z = voxel.z; // z = 6.54
```
is equivalent to 
```
const { x, y, z } = voxel; // x = 3.6, y = 7.4, z = 6.54
```
in ES6. If instead you want to store the values of voxel.x into a, voxel.y into b, and voxel.z into c, you have that freedom as well.
```
const { x : a, y : b, z : c } = voxel // a = 3.6, b = 7.4, c = 6.54
```

+ We can also assign variables from arrays using the following syntax: 

```
const [a, b,,, c] = [1, 2, 3, 4, 5, 6];
console.log(a, b, c); // 1, 2, 5
```

+ We can also use destructuring similarly to `slice`

```
const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];
console.log(a, b); // 1, 2
console.log(arr); // [3, 4, 5, 7]
```

+ We can also destructure objects passed into functions as arguments: 
```
const profileUpdate = (profileData) => {
  const { name, age, nationality, location } = profileData;
  // do something with these variables
}
```

### Getters and Setters 
Getter functions are meant to simply return (get) the value of an object's private variable to the user without the user directly accessing the private variable. Setter functions are meant to modify (set) the value of an object's private variable based on the value passed into the setter function. This change could involve calculations, or even overwriting the previous value completely.

```
class Book {
  constructor(author) {
    this._author = author;
  }
  // getter
  get writer(){
    return this._author;
  }
  // setter
  set writer(updatedAuthor){
    this._author = updatedAuthor;
  }
}
const lol = new Book('anonymous');
console.log(lol.writer);  // anonymous
lol.writer = 'wut';
console.log(lol.writer);  // wut
```

Notice the syntax we are using to invoke the getter and setter - as if they are not even functions.Getters and setters are important, because they hide internal implementation details.



### charAt
Strings are immuatable - the best way I've seen to modify a string is to create a new and use the `.charAt` and `.splice` methods 
```
after = after.charAt(0).toUpperCase()+after.slice(1);
```

### charCodeAt
The string method charCodeAt returns the ASCII character encoding at a given index in a string.  Below is a useful way of mapping all of the encodings to an array.  
```
str.split('').map(el => el.charCodeAt(0))
```

## Regex 
Example using the .test() method - pretty weird syntax with the string as the input. 
```
let myString = "freeCodeCamp";
let fccRegex = /freecodecamp/; // Change this line
let result = fccRegex.test(myString);
```
  
+ .match() extracts matches 
+ uses flags: i = case insensitive, g = more than the first match 
+ you can put whatever you want in a class: [aeiou] or [a-f], [a-z] etc. 
+ lazy matching - finds the smallest part of the string that matches the pattern
+ `[\w]` matches alphanumerics, `[\W]` matches non alphanumerics 
+ `[\d]` matches digits, `[\D]` is the inverse 
+ `[\s]` matches all whitespace characters, `[\S]` is the inverse 
+ `?` checks for all or none (think of it as optional)
+ .trim() and .replace() methods exist 
+ Add a `^` symbol to a class for NOT.  ex. not vowels: `[^aeiou]`
+ If you need to pass a variable to create a regex expression use: `var regex = new RegExp(variable, "i")`

### lookaheads 
We can use lookaheads that only match after the initial pattern is matched.  This example matches a group of letters of any length followed by an uppercase letter. 
```
var x = 'AllThe-small Things'
x.split(/(.*[a-z])(?=[A-Z])/)
```

### replace
The string object .replace method can used to mutate strings.  It's useful using regex expressions with parentheses.  The following expression matches a lowercase letter followed by an uppercase, then replaces it with a space inserted between them.  `$1` refers to the first `()` and `$2` refers to the second pair. 
```
var str = 'AllThe-small Things'
str.replace(/([a-z])([A-Z])/g, '$1 $2');
```


## Debugging 
Overall this wasn't the most informative section.  It mainly focused on common errors 
rather than debugging techniques.  I've done quite a bit of debugging though so I'm not 
exactly sorry that this section was short.
  
+ Use `console.log(typeof variable_name)` to return the type. 
    + Interestingly this isn't a function you wrap the object in.
+ OBOE - refers to off by one errors
   + if you access an out range index it `undefined` is usually the output
   + the following syntax should avoid this `for (let i = 0; i < obj.length; i++)`
<br> 


## Data Structures 
+ Arrays can store other arrays / JS objects 
+ `Array.push` adds elements to the end. `Array.unshift()` to the beginning.
    + .pop removes from the end / .shift removes from the beginning
+ `Array.slice(0:9)` - removes the first 10 elements 

The third (optional) argument in `splice` can replace an element.  This is a cool 
example of using it to update a color scheme: 
```
function colorChange(arr, index, newColor) {
  arr.splice(index, 1, newColor);
  return arr;
}

let colorScheme = ['#878787', '#a08794', '#bb7e8c', '#c9b6be', '#d1becf'];

colorScheme = colorChange(colorScheme, 2, '#332327');
// we have removed '#bb7e8c' and added '#332327' in its place
// colorScheme now equals ['#878787', '#a08794', '#332327', '#c9b6be', '#d1becf']
```
+ `slice` extracts array elements but doesn't modify the original array
    + `splice` is the same but it removes the selected elements 
+ the spread operator `...` allows us to copy arrays / insert them into other arrays 
    + `let thisArray = ['sage', 'rosemary', 'parsley', 'thyme'];`
    + `let thatArray = ['basil', 'cilantro', ...thisArray, 'coriander'];`
+ `arr.indexOf('element')` returns the index or -1 if it DNE
+ `arr.includes()` returns a boolean 
<br> 

Basic object operations
+ Use the dot operator to access properties `obj.prop1.prop2 etc.`
+ You can also use bracket notation `obj[key1][key2]`
+ You can use the delete keyword to remove properties: `delete obj.prop1;`
+ `Obj.hasOwnProperty(prop)` returns a boolean - really useful! 
+ We can iterate through keys in an object: 
    + `for (let key in obj) {obj[key]...}`
+ `Object.keys(input_obj)` returns all the keys in an object. 


## Basic Algorithm Scripting 
I included algorithms because I either found them interesting, learned something new, or found them difficult to puzzle through.  
  
**1.** Cool reverse way to reverse a string with array methods: 
```
function reverseString(str) {
  return str.split('').reverse().join('');
}
```
  
**2.** Recursion solution to factorial problem: 
```
function factorialize(num) {
  if (num === 0) { return 1; }
  return num * factorialize(num-1);
}
```
  
**3.** Find the longest word in a string, my solution:
```
function findLongestWordLength(str) {
  let lengths = str.split(' ').map(word => word.length)
  return Math.max(...lengths);
}
```

**4.** Match 'x' amount of characters at the end of a string:
```
function confirmEnding(str, target) {
  return str.slice(str.length - target.length) === target;
}
```

**5.** My solution to: Title case every word in a string. The key here was remembering that the string method `.replace` takes regex as an input and then a callback function.  I had to use map in order to use replace on every element of the array.  
```
function titleCase(str) {
  return str.toLowerCase().split(' ').map(el => el.replace(/^.{1}/, letter => letter.toUpperCase())).join(' ');
}
```

**6.** Remove all "falsy" values from an array.  This method uses the filter function that takes a callback function and filters out values based on true/false output.  The `Boolean` functions returns T/F based on the input.    
```
function bouncer(arr) {
  // Don't show a false ID to this bouncer.
  return arr.filter(Boolean)
}
```

**7.** Check if the all the characters in arr[1] are in arr[0]. My weird solution below.  I could have incorporated `.indexOf` instead of findIndex, and `.every` which is the same as `all` in R.   
```
function mutation(arr) {
  let arr0 = arr[0].toLowerCase().split('');
  let arr1 = arr[1].toLowerCase().split('');
  return arr1.map(el => arr0.findIndex(letter => el===letter)).includes(-1) ? false : true;
}
```

**8.** Split an array into groups of `size` and return then in a two dimensional array.  The first solution is mine where I used a bunch of additional counter variables.  The second solution is really elegant. It creates a newArr to store results in.  The while loop keeps running while there are elements left in `arr`.  Then we push and splice until `arr` is empty.
```
function chunkArrayInGroups(arr, size) {
  let newArr = [];
  let start = 0;
  let end = size; 
  let numIterations = Math.ceil(arr.length/size);

  for (let i = 0; i < numIterations; i++) {
    if (end > arr.length) {
      newArr[i] = arr.slice(start, arr.length);
    } else {
    newArr[i] = arr.slice(start, end);
    start += size; 
    end += size; 
    }
  }
  return newArr;
}
function chunkArrayInGroups(arr, size) {
  var newArr = [];
  while (arr.length) {
    newArr.push(arr.splice(0,size));
  }
return newArr;
}
```

## Object Oriented Programming
The software development process first defines a problem, then presents a solution. Object oriented programming is one of several major approaches to the software development process. As its name implies, object oriented programming organizes code into object definitions. These are sometimes called classes, and they group together data with related behavior. The data is an object's attributes, and the behavior (or functions) are methods.

+ object declaration: ```let object = {property: "value"}`
+ access properties with the dot operator: `object.property`
+ add a method to an object 
    +
    ```
let dog = {
  name: "Spot",
  numLegs: 4,
  sayLegs: function() {return `This dog has ${this.numLegs} legs.`}
};
```
+ Create a class constructor: 
    +
```
function Dog(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 4;
}
```
+ check that a variable is of a Class using `variable instanceOf class;`
+ own properties are defined directly on an object (not inherited)
    + You can loop through an objects properties (AND prototype properties): `for (let property in object){}`
+ prototype is an object shared among all instance of a class 
    + we can modify the prototype directly with: `Dog.prototype.numLegs = 4;`
+ we can check if the constructor is of a specific class: 
    +
```
let joinDogFraternity = (candidate) => {
  return candidate.constructor === Dog ? true : false;
}
```
+ Set methods in the prototype.  Also includes shorthand method definitions: 
    + when manually setting the prototype of an object it deletes the constructor.  Remember to include the `constructor` property in the prototype.
    +
```
function Dog(name) {
  this.name = name; 
}
Dog.prototype = {
  numLegs: 4,
  eat() {
    console.log('nom nom nom');
  },
  describe() {
    console.log(`My name is ${this.name}`);
  }
};
```
+ `isProtoTypeOf` method: 
    +
```
function Dog(name) {
  this.name = name;
}
let beagle = new Dog("Snoopy");
Dog.prototype.isPrototypeOf(beagle);
```
+ using inheritance means you won't repeat yourself (DRY)
+ `superType` = parent
+ this is the same as using the `new` operator: 
    + `let animal = Object.create(Animal.prototype);`
    + Object.create(obj) creates a new object, and sets obj as the new object's prototype
+ `subtype` = child 
    + set the prototype of the subtype (or child)—in this case, Bird—to be an instance of Animal: 
    + `Bird.prototype = Object.create(Animal.prototype);`
+ When an object inherits its prototype from another object, it also inherits the supertype's constructor property.  You need to reset the constructor property manually: `Bird.prototype.constructor = Bird;`
+ We can overwrite a prototype method by using the same name. 
+ `Mixin` a generic function we can use to give unrelated objects methods
    +
```
let bird = {
  name: "Donald",
  numLegs: 2
};
let boat = {
  name: "Warrior",
  type: "race-boat"
};
// Create a Mixin function
let glideMixin = function(obj) {
    obj.glide = function() {
        console.log('gliding!');
    }
};
glideMixin(bird);
glideMixin(boat);
bird.glide();
```

**Use Closures to create private variables:**  
We can make properties private by creating a variable within the constructor function. The scope of the variable is now in the constructor function -> so the variable can only be accessed or changed by methods within the constructor function.  
```
function Bird() {
  let weight = 15;
  this.getWeight = function() {//publicly available method
    return weight;
  }
}
```

**Use an IIFE to create a module:**  
Note that you have an immediately invoked function expression (IIFE) that returns an object motionModule. This returned object contains all of the mixin behaviors as properties of the object. The advantage of the module pattern is that all of the motion behaviors can be packaged into a single object that can then be used by other parts of your code. Here is an example using it:
```
let motionModule = (function () {
  return {
    glideMixin: function (obj) {
      obj.glide = function() {
        console.log("Gliding on the water");
      };
    },
    flyMixin: function(obj) {
      obj.fly = function() {
        console.log("Flying, wooosh!");
      };
    }
  }
}) (); // The two parentheses cause the function to be immediately invoked
motionModule.glideMixin(duck);
duck.glide();
```
<hr>


## Functional Programming Challenges 
Functional programming is an approach to software development based around the evaluation of functions. Like mathematics, functions in programming map input to output to produce a result. You can combine basic functions in many ways to build more and more complex programs. The functional programming software development approach breaks a program into small, testable parts. This section covers basic functional programming principles in JavaScript.
  **Callbacks** are the functions that are slipped or passed into another function to decide the invocation of that function. Functions that can be assigned to a variable, passed into another function, or returned from another function just like any other normal value, are called **first class** functions. In JavaScript, all functions are first class functions. The functions that take a function as an argument, or return a function as a return value are called **higher order** functions. When the functions are passed in to another function or returned from another function, then those functions which gets passed in or returned can be called a **lambda.** 
Example of these principles: 
```
const prepareGreenTea = () => 'greenTea';
const prepareBlackTea = () => 'blackTea';

const getTea = (prepareTea, numOfCups) => {
  const teaCups = [];
  for(let cups = 1; cups <= numOfCups; cups += 1) {
    const teaCup = prepareTea();
    teaCups.push(teaCup);
  }
  return teaCups;
};

const tea4GreenTeamFCC = getTea(prepareGreenTea, 27); // 
const tea4BlackTeamFCC = getTea(prepareBlackTea, 13); // 
```

+ Functional programming follows a few core principles:
+ Functions are independent from the state of the program or global variables. They only depend on the arguments passed into them to make a calculation
+ Functions try to limit any changes to the state of the program and avoid changes to the global objects holding data
+ Functions have minimal side effects in the program  

Super cool snippet of functional programming with one error: 
```
// tabs is an array of titles of each site open within the window
var Window = function(tabs) {
  this.tabs = tabs; // we keep a record of the array inside the object
};

// When you join two windows into one window
Window.prototype.join = function (otherWindow) {
  this.tabs = this.tabs.concat(otherWindow.tabs);
  return this;
};

// When you open a new tab at the end
Window.prototype.tabOpen = function (tab) {
  this.tabs.push('new tab'); // let's open a new tab for now
  return this;
};

// When you close a tab
Window.prototype.tabClose = function (index) {
  /* the splice call modifies the arry - wrong method to use here */
  var tabsBeforeIndex = this.tabs.splice(0, index); // get the tabs before the tab
  var tabsAfterIndex = this.tabs.splice(index); // get the tabs after the tab

  this.tabs = tabsBeforeIndex.concat(tabsAfterIndex); // join them together 
  return this;
 };

// Let's create three browser windows
var workWindow = new Window(['GMail', 'Inbox', 'Work mail', 'Docs', 'freeCodeCamp']); // Your mailbox, drive, and other work sites
var socialWindow = new Window(['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium']); // Social sites
var videoWindow = new Window(['Netflix', 'YouTube', 'Vimeo', 'Vine']); //  Entertainment sites

// Now perform the tab opening, closing, and other operations
var finalTabs = socialWindow
                    .tabOpen() // Open a new tab for cat memes
                    .join(videoWindow.tabClose(2)) // Close third tab in video window, and join
                    .join(workWindow.tabClose(1).tabOpen());

alert(finalTabs.tabs);
```

Add a user-defined map and filter prototypes methods to the global Array object: 
```
var s = [23, 65, 98, 5];

Array.prototype.myMap = function(callback){
  var newArray = [];
  for(let i = 0; i < this.length; i++) {
    newArray.push(callback(this[i]));
  }
  // the forEach method also works 
  // this.forEach(a => newArray.push(callback(a)));
  return newArray;
};

var new_s = s.myMap(function(item){
  return item * 2;
});

Array.prototype.myFilter = function(callback){
  var newArray = [];
  // Add your code below this line
  this.forEach(el => {if (callback(el)) {
      newArray.push(el);
    }
  });
  // Add your code above this line
  return newArray;
};
```

### filter
`.filter` method takes a callback function input and returns elements in a new array if it evaluates to true
The following code chunk works, but it won't work if we wrap {} around the arrown function in .filter.  Why is that?
```
var filteredList = watchList.filter(el => parseInt(el.imdbRating) >= 8).map(el => {return {title: el.Title, rating: el.imdbRating}});
```

### concat
+ `.concat` allows us to push items to the end of an array in a non mutating way. 

### reduce
The array `.reduce` methods takes simplifies an into an object of length one based on a callback function. The `a and b` inputs to the function are `arr[0]` and `arr[1]` on the first call, then the result of the first call and `arr[2]` on the second call, etc. 
```
var nolan_movies = watchList.filter(el => el.Director === 'Christopher Nolan');
var averageRating = nolan_movies.map(el => parseFloat(el.imdbRating)).reduce((a, b) => a + b)/(nolan_movies.length);
```
  
### Sorting examples
Sorting defaults to unicode which converts numbers to characters.  We need callback functions to sort numeric values correctly.  Sort also mutates the original array.  
```
function ascendingOrder(arr) {
  return arr.sort(function(a, b) {
    return a - b;
  });
}
ascendingOrder([1, 5, 2, 3, 4]);

function reverseAlpha(arr) {
  return arr.sort(function(a, b) {
    return a < b;
  });
}
reverseAlpha(['l', 'h', 'z', 'b', 's']);
```

### join  
The array `.join('delimiter')` method joins elements of an array using a delimiter
```
['hello', 'world'].join(' ');
```

### every / some
The `.every` method takes a callback function and checks if every value is true. The `.some` method (any in R) method checks if any applications of the callback function are true
    
**Curry and Partial Application:**
+ `arity` is the number of arguments a function requires
+ `currying` a function means converting one function of N arity (arguments) into N functions of arity 1.  
+ partial application can be described as applying a few arguments to a function at a time and returning another function that is applied to more arguments
    + this basically looks like big nested function calls (pretty weird)
```
function add(x) {
  return function(y) {
    return function(z) {
      return x + y + z;
    }
  }
}
add(10)(20)(30);
```
<hr> 


## Intermediate Algorithm Scripting 

1. Create a `range` function for an unsorted 2-number array that sums all numbers (inclusive).
```
function sumAll(arr) {
  var sortedArr = arr.sort((a,b) => a-b);
  var firstNum = arr[0];
  var lastNum = arr[1];
  // Using Arithmetic Progression summing formula
  var sum = (lastNum - firstNum + 1) * (firstNum + lastNum) / 2;
  return sum;
}
```
2. Compare two arrays and return a new array with any items only found in one of the two given arrays, but not both. In other words, return the symmetric difference of the two arrays.
- Could use a nested for loop
- Could decompose into one array then check for duplicates
- My solution: 
```
function diffArray(arr1, arr2) {
  return [...arr1, ...arr2].filter(el => !(arr1.includes(el) && arr2.includes(el)));
}
```
3. You will be provided with an initial array (the first argument in the destroyer function), followed by one or more arguments. Remove all elements from the initial array that are of the same value as these arguments.
- solution was required to use the `arguments` object 
- `arguments` is not an array and only has the `length` property
- we use `Array.from` to convert `arguments` to an array. 
```
function destroyer(arr) {
  let destroyers = Array.from(arguments).splice(1);
  return arguments[0].filter(el => !(destroyers.includes(el)));
}
destroyer([1, 2, 3, 1, 2, 3], 2, 3);
```

4. Translate the provided string to pig latin. Pig Latin takes the first consonant (or consonant cluster) of an English word, moves it to the end of the word and suffixes an "ay". If a word begins with a vowel you just add "way" to the end.
```
function translatePigLatin(str) {
  if (str.split('')[0].match(/[aeiou]/) !== null) {
    return str + 'way';
  } 
  let chars = str.match(/[^aeiou]+/).toString().split('');
  return (str.split('').splice(chars.length).join('') + chars.join('') + 'ay');
}
translatePigLatin("consonant");
```

5. Convert a string to spinal case. Spinal case is all-lowercase-words-joined-by-dashes.
- split string on all non alphabet characters 
- join string on dashes 
  
6. Perform a search and replace on the sentence using the arguments provided and return the new sentence. Preserve the case of the first character in the original word when you are replacing it. For example if you mean to replace the word "Book" with the word "dog", it should be replaced as "Dog". 
- match pattern and extract (case insensitive regex)
- if you need to pass a variable to create a regex expression use: `var regex = new RegExp(variable, "i")`
- check for caps using str === str.toLowerCase()
- if true then replace, if false capitalize then replace

```
function myReplace(str, before, after) {
  var regex = new RegExp(before, "i"); 
  var out = str.match(regex).toString(); 
  if (out === before.toLowerCase()) {
    return str.replace(regex, after);
  } else {
    let arr = after.split('')
    var firstLetter = arr.shift().toUpperCase();
    arr.unshift(firstLetter); 
    var afterCapitalized = arr.join('');
    return str.replace(regex, afterCapitalized);
  }
}
myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");

// Cool alternate solution to uppercase matching and string mutations.
//Check whether the first letter is uppercase or not
  if(/[A-Z]/.test(before[0])){
  //Change the word to be capitalized
    after = after.charAt(0).toUpperCase()+after.slice(1);
}
```

7. The DNA strand is missing the pairing element. Take each character, get its pair, and return the results as a 2d array.
- create a hashmap object with all pairs 
- split string into array, then map to a 2-D array returning each element + its hashmap lookup
```
function pairElement(str) {
  const hashmap = {
    A: 'T',
    T: 'A', 
    C: 'G',
    G: 'C'
  }
  let dna = str.split('');
  return dna.map(el => [el, hashmap[el]])
}
pairElement("GCG");
```

8. Find the missing letter in the passed letter range and return it. If all letters are present in the range, return undefined.
- want to avoid using a for loop 
- decompose the input string to an array
- loop through each entry, if it matches return true and push the element onto a regex exp
- when it returns false we return that letter
- abandoning the above approach ^ 
- find the starting index in the alphabet string by using `.findIndex` 
- `slice` the alphabet string from index to str.length 
- compare each value, if false return it 

```
// First attempt that didn't work 
function fearNotLetter(str) {
  const alphabet = "abcdefghijklmnopqrstuvwxyz"; 
  let letters = str.split('');
  for (let i=0; i < letters.length; i++) {
    var regex = new RegExp(letters.slice(0,i+1).join(''))
    if (!alphabet.match(regex)) {
      return letters[i];
    }
  }

  return undefined;
}
fearNotLetter("abce");
```

```
// Second attempt
function fearNotLetter(str) {
  let alphabet = "abcdefghijklmnopqrstuvwxyz".split('');
  let start = alphabet.findIndex(el => el === str.charAt(0)); 
  let key = alphabet.slice(start, start + str.length);
  let letters = str.split('');

  for (let i = 0; i < letters.length; i++) {
    if (letters[i] !== key[i]) {
      return key[i];
    }
  }
  return undefined;
}
console.log(fearNotLetter("abce"));
```

9. Check if the predicate (second argument) is truthy on all elements of a collection (first argument). In other words, you are given an array collection of objects. The predicate pre will be an object property and you need to return true if its value is truthy. Otherwise, return false.
- use the Boolean function to convert to true/false
- select values in object using []

```
function truthCheck(collection, pre) {
  return collection.map(el => Boolean(el[pre])).every(el => el === true);
}
truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");
```

10. Create a function that sums two arguments together. If only one argument is provided, then return a function that expects one argument and returns the sum. For example, addTogether(2, 3) should return 5, and addTogether(2) should return a function. Calling this returned function with a single argument will then return the sum: var sumTwoAnd = addTogether(2); sumTwoAnd(3) returns 5.
- need to use the `arguments object for this` 
- if it's length 2 return the sum 
- if it's length 1 return a function 
- my solution ended up looking terrible:

```
function addTogether(arg1, arg2) {
  if (!(typeof arg1 === 'number')) {
    return undefined; 
  } 
    if (arguments.length === 2) {
      if (typeof arg2 === 'number') {
        return arguments[0] + arguments[1];
      } else {
        return undefined;
      }
    }
    if (arguments.length === 1) {
       return function(y) {
         if (typeof y === 'number') {
           return arg1 + y;
         } else {
           return undefined;
         }
       } 
    }
    return undefined; 
}
addTogether(2,3);
```
- try to improve on it before reading more solutions
- use a function to check the typeof the args

11. Write a function that takes two or more arrays and returns a new array of unique values in the order of the original provided arrays.
- the first array always stays the same 
- combine the next arguments into one (here use .splice and .reduce to create one array)
- if the first array doesn't contain an argument the .push it into that array. 
- use forEach so we don't return an array? 

```
function uniteUnique() {
  let unique = arguments[0];
  let numbers = Array.from(arguments).splice(1).reduce((a,b) => [...a, ...b]);
  console.log(numbers); // see what this looks like
  numbers.forEach(el => { 
    if (!(unique.includes(el)))
      unique.push(el);
  })
  return unique;
}
uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
```

12. Convert the characters &, <, >, " (double quote), and ' (apostrophe), in a string to their corresponding HTML entities.
- create a hashmap
- then use str.split, map, and join 
```
function convertHTML(str) {
  const hashmap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  }
  return str.split('').map(el => {return hashmap[el] ? hashmap[el] : el;}).join('');
}
convertHTML("Dolce & Gabbana");
```

13. Given a positive integer num, return the sum of all odd Fibonacci numbers that are less than or equal to num. The first two numbers in the Fibonacci sequence are 1 and 1. Every additional number in the sequence is the sum of the two previous numbers. The first six numbers of the Fibonacci sequence are 1, 1, 2, 3, 5 and 8.
- create the fibonacci sequence 
- go through and use .reduce() to sum it for odd entries
- might need to use filter first to get rid of even entries 
```
function sumFibs(num) {
  let arr = [1, 1]
  while (arr.slice(-1) < num) {
    arr.push(arr.slice(-2).reduce((a, b) => a+b));
  }
  arr.slice(-1) > num ? arr.pop() : 'do nothing';
  return arr.filter(el => el % 2 !== 0).reduce((a, b) => a+b);
}
console.log(sumFibs(15));
```

14. Return an English translated sentence of the passed binary string. The binary string will be space separated. 
- split into an array on whitespace 
- convert the binary string to its decimal value using parseInt(, 2)
- retrieve the ASCII decimal value using the string method: `String.fromCharChode()`
```
function binaryAgent(str) {
  return str.split(' ').map(el => String.fromCharCode(parseInt(el, 2))).join('');
}
console.log(binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"));
```

15. Given the array arr, iterate through and remove each element starting from the first element (the 0 index) until the function func returns true when the iterated element is passed through it. Then return the rest of the array once the condition is satisfied, otherwise, arr should be returned as an empty array. 
```
dropElements([1, 2, 3, 4], function(n) {return n >= 3;}) should return [3, 4]
```
- makes sense to use a for loop 
- could also try using filter (doesn't make sense because we return on the first true)
- in the for loop I made a OBOE initially because i was checking function(arr[i]) - but if it was false then I shifted off the first element - modifying the input array.  Then the next iteration of the loop, arr[1], was actually the third element because the first one was shifted off. 
- used a while loop instead of a for loop
```
function dropElements(arr, func) {
  while (!func(arr[0])) {
    arr.shift();
  }
  return arr; 
}
console.log(dropElements([1, 2, 3], function(n) {return n < 3; }));
console.log(dropElements([1, 2, 3, 4], function(n) {return n >= 3;}));
console.log(dropElements([0, 1, 0, 1], function(n) {return n === 1;}));
```

16. Fill in the object constructor with the following methods below: getFirstName() getLastName() getFullName() setFirstName(first) setLastName(last) setFullName(firstAndLast). 

```
var Person = function(input) {
  var arr = input.split(' ');
  // Complete the method below and implement the others similarly
  this.getFullName = function() {
    return arr.join(' ');
  };

  this.getFirstName = function() {
    return arr[0];
  };

  this.getLastName = function() {
    return arr[1];
  };

  this.setFirstName = function(input) {
    arr[0] = input;
  };

  this.setLastName = function(input) {
    arr[1] = input;
  }

  this.setFullName = function(input) {
    arr = input.split(' ');
  }
};

var bob = new Person('Bob Ross');
bob.getFullName();
```

17. Return a new array that transforms the elements' average altitude into their orbital periods (in seconds). The array will contain objects in the format {name: 'name', avgAlt: avgAlt}. You can read about orbital periods on Wikipedia. The values should be rounded to the nearest whole number. The body being orbited is Earth. The radius of the earth is 6367.4447 kilometers, and the GM value of earth is 398600.4418 km3s-2.
- create an obortial period class constructor 
- it takes in the satellites name and avgAlt and returns an object with name and orbital period 
- I could've also looped through the array, calculated period for each object, and deleted the avgAlt prop from each one.  

```
function orbitalPeriod(arr) {
  function calculatePeriod(altitude) {
    var GM = 398600.4418;
    var earthRadius = 6367.4447;
    var radius = earthRadius + altitude; 
    return Math.round(2*Math.PI*Math.sqrt(Math.pow(radius, 3)/GM));
  }

  function orbitalPeriod(name, avgAlt) {
    return {name: name, orbitalPeriod: calculatePeriod(avgAlt)};
  }

  return arr.map(el => orbitalPeriod(el['name'], el['avgAlt']));
}
console.log(orbitalPeriod([{name : "sputnik", avgAlt : 35873.5553}]));
```

18. Sum all the prime numbers up to and including the provided number. A prime number is defined as a number greater than one and having only two divisors, one and itself. For example, 2 is a prime number because it's only divisible by one and two.

- create a sequence from 2:num 
- write isPrime - return TRUE/FALSE, use this in conjunction with `.filter`
- use `.reduce` to sum the remaining array

```
function sumPrimes(num) {
  var isPrime = function(num) {
    for (let i = 2; i < num; i++) {
      if (num%i == 0) {
        return false;
      }
    }
    return true; 
  }
  let arr = [];
  for (let i = 2; i <= num; i++) {arr.push(i)};

  return arr.filter(el => isPrime(el)).reduce((a,b) => a+b);
}
console.log(sumPrimes(10));
```

19. Find the smallest common multiple of the provided parameters that can be evenly divided by both, as well as by all sequential numbers in the range between these parameters. The range will be an array of two numbers that will not necessarily be in numerical order. For example, if given 1 and 3, find the smallest common multiple of both 1 and 3 that is also evenly divisible by all numbers between 1 and 3. The answer here would be 6.

- sort array 
- create a sequence from the end of the array to end^factorial

20. Make a function that looks through an array of objects (first argument) and returns an array of all objects that have matching name and value pairs (second argument). Each name and value pair of the source object has to be present in the object from the collection if it is to be included in the returned array.

- create an array of the keys from the second argument 
- call filter method on collection (start looping through each object)
- then for each object we call the keys array - use the (every) method to test that each key-value pair is in an object (we could have also used map) - the point is we have two loops with these two methods

```
function whatIsInAName(collection, source) {
  var keys = Object.keys(source);
  
  return collection.filter(obj => keys.every(key => obj.hasOwnProperty(key) && obj[key] === source[key]));
}
console.log(whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" }));
console.log(whatIsInAName([{ "apple": 1, "bat": 2 }, { "bat": 2 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "bat": 2 }));
```


<hr>


## Project 1: Palindrome checker
Return true if the given string is a palindrome. Otherwise, return false. A palindrome is a word or sentence that's spelled the same way both forward and backward, ignoring punctuation, case, and spacing.

- check length of the string, remove middle character if it's odd.  (does this apply for strings with spaces?)
- seems like I should remove whitespace, underscores and periods from the strings.
- check length of the string 
- for loop solution: start at the front and back of the string using `.charAt` checking if values are equal, break if they aren't. 

```
function palindrome(str) {
  let chars = str.replace(/[\W]|_/g, "").toLowerCase();
  console.log(chars);

  // for loop solution 
  var out = true; 
  for (let i = 0; i < chars.length/2; i++) {
    out = chars.charAt(i) === chars.charAt(chars.length-i-1);
    if (out === false) {
      break;
    }
  }
  return out;
  
}
console.log(palindrome("eye"));
console.log(palindrome("1 eye for of 1 eye."));
console.log(palindrome("0_0 (: /-\ :) 0-0"));
console.log(palindrome("My age is 0, 0 si ega ym."));
```

## Project 2: Roman Numerals
Roman Numeral Converter. Convert the given number into a roman numeral. All [roman numerals](https://www.mathsisfun.com/roman-numerals.html) answers should be provided in upper-case.
- initially thought of writing four functions: one each of the places: ones, tens, hundreds, and thousands columns.  
- then I realized the body of these functions would be the same: except for the characters it assigns 
- we can combine then into one function that takes two inputs: a number (0-9) and a character array of roman numerals or "rules" to assign.  

```
function convertToRoman(num) {
  var numbers = num.toString().split('').reverse().map(el => parseInt(el));
  var romanNumerals = [['I', 'V', 'X'], ['X', 'L', 'C'],
                      ['C', 'D', 'M'], ['M', 'Vbar', 'Xbar']];
  var inputs = [];
  for (let i = 0; i < numbers.length; i++) {
      inputs[i] = [numbers[i], romanNumerals[i]];
  }

  var replaceWithRoman = function(num, romanNumerals) {
     let out; 
     switch(true) {
        case num == 0:
            out = '';
            break;
        case num <= 3:
            out = romanNumerals[0].repeat(num);
            break;
        case num == 4:
            out = romanNumerals[0] + romanNumerals[1];
            break;
        case num <= 8:
            out = romanNumerals[1] + romanNumerals[0].repeat(num-5);
            break;
        case num == 9: 
            out = romanNumerals[0] + romanNumerals[2];
            break;
     }
     return out;
 }
 return inputs.map(el => replaceWithRoman(el[0], el[1])).reverse().join('')
}
console.log(convertToRoman(36));
console.log(convertToRoman(400));
console.log(convertToRoman(1000));
```

<hr>

## Project 3: Caesar's Cipher
One of the simplest and most widely known ciphers is a Caesar cipher, also known as a shift cipher. In a shift cipher the meanings of the letters are shifted by some set amount. A common modern use is the ROT13 cipher, where the values of the letters are shifted by 13 places. Thus 'A' ↔ 'N', 'B' ↔ 'O' and so on. Write a function which takes a ROT13 encoded string as input and returns a decoded string.

- A is 65 and Z is 90 in ASCII encodings 
- return each characters charCode `str.split('').map(el => el.charCodeAt(0))`
- decoding algorithm is easy if you write out 65:90 and 65:90 + 13.  You see that 65-77 is + 13, and 78-90 is -13.  So we just write an if-else statement. 

```
function rot13(str) { // LBH QVQ VG!
  const rot13Decode = function(num) {
    return (num < 65 || num > 90) ? num : num <= 77 ? num + 13 : num - 13;
  }
  let asciiCodes = str.split('').map(el => el.charCodeAt(0));

  return asciiCodes.map(el => String.fromCharCode(rot13Decode(el))).join('');
}
rot13("SERR PBQR PNZC");
```

<hr> 

## Project 4: Telephone Number Validator
Return true if the passed string looks like a valid US phone number. The user may fill out the form field any way they choose as long as it has the format of a valid US number.

- probably need to write a lot of rules
- check that first character is either a number or a "(" - if not return false
- created a function that returned true / false for every invalid entry 
- created an array of each function call on the string input 
- tested that every entry in the array was true 

```
function telephoneCheck(str) {
  const testFirstChar = function(str) {
    let regex = /[\d]|\(/;
    return regex.test(str.charAt(0));
  } 

  const testLength = function(str) {
    return str.length < 10 ? false : true
  }

  // if a string contains parentheses, check that they're pattern: (555)
  const testParentheses = function(str) {
    let out = true; 
    var regex = /\(|\)/;
    if (regex.test(str)) {
      var regex = /\([\d]{3}\)/;
      out = regex.test(str);
    }
    return out; 
  }

  const countIntegersInStr = function(str) {
    let regex = /[\d]/;
    return str.split('').map(el => regex.test(el)).filter(el => el === true).length;
  }

  const testNumberOfIntegers = function(str) {
    return countIntegersInStr(str) > 11 ? false : true;
  }

  const testCountryCode = function(str) {
    return (countIntegersInStr(str) === 11) ? (str.charAt(0) == 1) ? true : false : true;
  }

  const testSpecialCharacters = function(str) {
    let regex = /[\d]|-|\(|\)|[\s]/;
    return str.split('').map(el => regex.test(el)).every(el => el === true);
  }

  let tests = [testFirstChar(str), testLength(str), testParentheses(str),
               testNumberOfIntegers(str), testCountryCode(str),
               testSpecialCharacters(str)];

  return tests.every(el => el === true);
}
console.log(telephoneCheck("555-555-5555?"));
```

<hr> 


## Project 5: Cash Register
Design a cash register drawer function checkCashRegister() that accepts purchase price as the first argument (price), payment as the second argument (cash), and cash-in-drawer (cid) as the third argument. Example input: ```
checkCashRegister(19.5, 20, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]]);
```
