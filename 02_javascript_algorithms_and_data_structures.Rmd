# JavaScript Algorithms and Data Structures FCC 
These are my notes from the JavaScript Algorithms and Data Structures certification from the<a href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript"> FreeCodeCamp lessons</a>

### Mutating strings .charAt() methods
Strings are immuatable - the best way I've seen to modify a string is to create a new and use the `.charAt` and `.splice` methods 
```
after = after.charAt(0).toUpperCase()+after.slice(1);
```

## ES6 
Arrow function defintion syntax: 
```
let printAandB = (a, b) => {
  console.log(`${a} = a and ${b} = b`);
}
```

## Regex 
Example using the .test() method - pretty weird syntax with the string as the input. 
```
let myString = "freeCodeCamp";
let fccRegex = /freecodecamp/; // Change this line
let result = fccRegex.test(myString);
```
  
+ .match() extracts matches 
+ uses flags: i = case insensitive, g = more than the first match 
+ you can put whatever you want in a class: [aeiou] or [a-f], [a-z] etc. 
+ lazy matching - finds the smallest part of the string that matches the pattern
+ `[\w]` matches alphanumerics, `[\W]` matches non alphanumerics 
+ `[\d]` matches digits, `[\D]` is the inverse 
+ `[\s]` matches all whitespace characters, `[\S]` is the inverse 
+ `?` checks for all or none (think of it as optional)
+ .trim() and .replace() methods exist 
+ Add a `^` symbol to a class for NOT.  ex. not vowels: `[^aeiou]`
+ If you need to pass a variable to create a regex expression use: `var regex = new RegExp(variable, "i")`

### lookaheads 
We can use lookaheads that only match after the initial pattern is matched.  This example matches a group of letters of any length followed by an uppercase letter. 
```
var x = 'AllThe-small Things'
x.split(/(.*[a-z])(?=[A-Z])/)
```

### replace
The string object .replace method can used to mutate strings.  It's useful using regex expressions with parentheses.  The following expression matches a lowercase letter followed by an uppercase, then replaces it with a space inserted between them.  `$1` refers to the first `()` and `$2` refers to the second pair. 
```
var str = 'AllThe-small Things'
str.replace(/([a-z])([A-Z])/g, '$1 $2');
```


## Debugging 
Overall this wasn't the most informative section.  It mainly focused on common errors 
rather than debugging techniques.  I've done quite a bit of debugging though so I'm not 
exactly sorry that this section was short.
  
+ Use `console.log(typeof variable_name)` to return the type. 
    + Interestingly this isn't a function you wrap the object in.
+ OBOE - refers to off by one errors
   + if you access an out range index it `undefined` is usually the output
   + the following syntax should avoid this `for (let i = 0; i < obj.length; i++)`
<br> 


## Data Structures 
+ Arrays can store other arrays / JS objects 
+ `Array.push` adds elements to the end. `Array.unshift()` to the beginning.
    + .pop removes from the end / .shift removes from the beginning
+ `Array.slice(0:9)` - removes the first 10 elements 

The third (optional) argument in `splice` can replace an element.  This is a cool 
example of using it to update a color scheme: 
```
function colorChange(arr, index, newColor) {
  arr.splice(index, 1, newColor);
  return arr;
}

let colorScheme = ['#878787', '#a08794', '#bb7e8c', '#c9b6be', '#d1becf'];

colorScheme = colorChange(colorScheme, 2, '#332327');
// we have removed '#bb7e8c' and added '#332327' in its place
// colorScheme now equals ['#878787', '#a08794', '#332327', '#c9b6be', '#d1becf']
```
+ `slice` extracts array elements but doesn't modify the original array
    + `splice` is the same but it removes the selected elements 
+ the spread operator `...` allows us to copy arrays / insert them into other arrays 
    + `let thisArray = ['sage', 'rosemary', 'parsley', 'thyme'];`
    + `let thatArray = ['basil', 'cilantro', ...thisArray, 'coriander'];`
+ `arr.indexOf('element')` returns the index or -1 if it DNE
+ `arr.includes()` returns a boolean 
<br> 

Basic object operations
+ Use the dot operator to access properties `obj.prop1.prop2 etc.`
+ You can also use bracket notation `obj[key1][key2]`
+ You can use the delete keyword to remove properties: `delete obj.prop1;`
+ `Obj.hasOwnProperty(prop)` returns a boolean - really useful! 
+ We can iterate through keys in an object: 
    + `for (let key in obj) {obj[key]...}`
+ `Object.keys(input_obj)` returns all the keys in an object. 


## Basic Algorithm Scripting 
I included algorithms because I either found them interesting, learned something new, or found them difficult to puzzle through.  
  
**1.** Cool reverse way to reverse a string with array methods: 
```
function reverseString(str) {
  return str.split('').reverse().join('');
}
```
  
**2.** Recursion solution to factorial problem: 
```
function factorialize(num) {
  if (num === 0) { return 1; }
  return num * factorialize(num-1);
}
```
  
**3.** Find the longest word in a string, my solution:
```
function findLongestWordLength(str) {
  let lengths = str.split(' ').map(word => word.length)
  return Math.max(...lengths);
}
```

**4.** Match 'x' amount of characters at the end of a string:
```
function confirmEnding(str, target) {
  return str.slice(str.length - target.length) === target;
}
```

**5.** My solution to: Title case every word in a string. The key here was remembering that the string method `.replace` takes regex as an input and then a callback function.  I had to use map in order to use replace on every element of the array.  
```
function titleCase(str) {
  return str.toLowerCase().split(' ').map(el => el.replace(/^.{1}/, letter => letter.toUpperCase())).join(' ');
}
```

**6.** Remove all "falsy" values from an array.  This method uses the filter function that takes a callback function and filters out values based on true/false output.  The `Boolean` functions returns T/F based on the input.    
```
function bouncer(arr) {
  // Don't show a false ID to this bouncer.
  return arr.filter(Boolean)
}
```

**7.** Check if the all the characters in arr[1] are in arr[0]. My weird solution below.  I could have incorporated `.indexOf` instead of findIndex, and `.every` which is the same as `all` in R.   
```
function mutation(arr) {
  let arr0 = arr[0].toLowerCase().split('');
  let arr1 = arr[1].toLowerCase().split('');
  return arr1.map(el => arr0.findIndex(letter => el===letter)).includes(-1) ? false : true;
}
```

**8.** Split an array into groups of `size` and return then in a two dimensional array.  The first solution is mine where I used a bunch of additional counter variables.  The second solution is really elegant. It creates a newArr to store results in.  The while loop keeps running while there are elements left in `arr`.  Then we push and splice until `arr` is empty.
```
function chunkArrayInGroups(arr, size) {
  let newArr = [];
  let start = 0;
  let end = size; 
  let numIterations = Math.ceil(arr.length/size);

  for (let i = 0; i < numIterations; i++) {
    if (end > arr.length) {
      newArr[i] = arr.slice(start, arr.length);
    } else {
    newArr[i] = arr.slice(start, end);
    start += size; 
    end += size; 
    }
  }
  return newArr;
}
function chunkArrayInGroups(arr, size) {
  var newArr = [];
  while (arr.length) {
    newArr.push(arr.splice(0,size));
  }
return newArr;
}
```

## Object Oriented Programming
The software development process first defines a problem, then presents a solution. Object oriented programming is one of several major approaches to the software development process. As its name implies, object oriented programming organizes code into object definitions. These are sometimes called classes, and they group together data with related behavior. The data is an object's attributes, and the behavior (or functions) are methods.

+ object declaration: ```let object = {property: "value"}`
+ access properties with the dot operator: `object.property`
+ add a method to an object 
    +
    ```
let dog = {
  name: "Spot",
  numLegs: 4,
  sayLegs: function() {return `This dog has ${this.numLegs} legs.`}
};
```
+ Create a class constructor: 
    +
```
function Dog(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 4;
}
```
+ check that a variable is of a Class using `variable instanceOf class;`
+ own properties are defined directly on an object (not inherited)
    + You can loop through an objects properties (AND prototype properties): `for (let property in object){}`
+ prototype is an object shared among all instance of a class 
    + we can modify the prototype directly with: `Dog.prototype.numLegs = 4;`
+ we can check if the constructor is of a specific class: 
    +
```
let joinDogFraternity = (candidate) => {
  return candidate.constructor === Dog ? true : false;
}
```
+ Set methods in the prototype.  Also includes shorthand method definitions: 
    + when manually setting the prototype of an object it deletes the constructor.  Remember to include the `constructor` property in the prototype.
    +
```
function Dog(name) {
  this.name = name; 
}
Dog.prototype = {
  numLegs: 4,
  eat() {
    console.log('nom nom nom');
  },
  describe() {
    console.log(`My name is ${this.name}`);
  }
};
```
+ `isProtoTypeOf` method: 
    +
```
function Dog(name) {
  this.name = name;
}
let beagle = new Dog("Snoopy");
Dog.prototype.isPrototypeOf(beagle);
```
+ using inheritance means you won't repeat yourself (DRY)
+ `superType` = parent
+ this is the same as using the `new` operator: 
    + `let animal = Object.create(Animal.prototype);`
    + Object.create(obj) creates a new object, and sets obj as the new object's prototype
+ `subtype` = child 
    + set the prototype of the subtype (or child)—in this case, Bird—to be an instance of Animal: 
    + `Bird.prototype = Object.create(Animal.prototype);`
+ When an object inherits its prototype from another object, it also inherits the supertype's constructor property.  You need to reset the constructor property manually: `Bird.prototype.constructor = Bird;`
+ We can overwrite a prototype method by using the same name. 
+ `Mixin` a generic function we can use to give unrelated objects methods
    +
```
let bird = {
  name: "Donald",
  numLegs: 2
};
let boat = {
  name: "Warrior",
  type: "race-boat"
};
// Create a Mixin function
let glideMixin = function(obj) {
    obj.glide = function() {
        console.log('gliding!');
    }
};
glideMixin(bird);
glideMixin(boat);
bird.glide();
```

**Use Closures to create private variables:**  
We can make properties private by creating a variable within the constructor function. The scope of the variable is now in the constructor function -> so the variable can only be accessed or changed by methods within the constructor function.  
```
function Bird() {
  let weight = 15;
  this.getWeight = function() {//publicly available method
    return weight;
  }
}
```

**Use an IIFE to create a module:**  
Note that you have an immediately invoked function expression (IIFE) that returns an object motionModule. This returned object contains all of the mixin behaviors as properties of the object. The advantage of the module pattern is that all of the motion behaviors can be packaged into a single object that can then be used by other parts of your code. Here is an example using it:
```
let motionModule = (function () {
  return {
    glideMixin: function (obj) {
      obj.glide = function() {
        console.log("Gliding on the water");
      };
    },
    flyMixin: function(obj) {
      obj.fly = function() {
        console.log("Flying, wooosh!");
      };
    }
  }
}) (); // The two parentheses cause the function to be immediately invoked
motionModule.glideMixin(duck);
duck.glide();
```
<hr>


## Functional Programming Challenges 
Functional programming is an approach to software development based around the evaluation of functions. Like mathematics, functions in programming map input to output to produce a result. You can combine basic functions in many ways to build more and more complex programs. The functional programming software development approach breaks a program into small, testable parts. This section covers basic functional programming principles in JavaScript.
  **Callbacks** are the functions that are slipped or passed into another function to decide the invocation of that function. Functions that can be assigned to a variable, passed into another function, or returned from another function just like any other normal value, are called **first class** functions. In JavaScript, all functions are first class functions. The functions that take a function as an argument, or return a function as a return value are called **higher order** functions. When the functions are passed in to another function or returned from another function, then those functions which gets passed in or returned can be called a **lambda.** 
Example of these principles: 
```
const prepareGreenTea = () => 'greenTea';
const prepareBlackTea = () => 'blackTea';

const getTea = (prepareTea, numOfCups) => {
  const teaCups = [];
  for(let cups = 1; cups <= numOfCups; cups += 1) {
    const teaCup = prepareTea();
    teaCups.push(teaCup);
  }
  return teaCups;
};

const tea4GreenTeamFCC = getTea(prepareGreenTea, 27); // 
const tea4BlackTeamFCC = getTea(prepareBlackTea, 13); // 
```

+ Functional programming follows a few core principles:
+ Functions are independent from the state of the program or global variables. They only depend on the arguments passed into them to make a calculation
+ Functions try to limit any changes to the state of the program and avoid changes to the global objects holding data
+ Functions have minimal side effects in the program  

Super cool snippet of functional programming with one error: 
```
// tabs is an array of titles of each site open within the window
var Window = function(tabs) {
  this.tabs = tabs; // we keep a record of the array inside the object
};

// When you join two windows into one window
Window.prototype.join = function (otherWindow) {
  this.tabs = this.tabs.concat(otherWindow.tabs);
  return this;
};

// When you open a new tab at the end
Window.prototype.tabOpen = function (tab) {
  this.tabs.push('new tab'); // let's open a new tab for now
  return this;
};

// When you close a tab
Window.prototype.tabClose = function (index) {
  /* the splice call modifies the arry - wrong method to use here */
  var tabsBeforeIndex = this.tabs.splice(0, index); // get the tabs before the tab
  var tabsAfterIndex = this.tabs.splice(index); // get the tabs after the tab

  this.tabs = tabsBeforeIndex.concat(tabsAfterIndex); // join them together 
  return this;
 };

// Let's create three browser windows
var workWindow = new Window(['GMail', 'Inbox', 'Work mail', 'Docs', 'freeCodeCamp']); // Your mailbox, drive, and other work sites
var socialWindow = new Window(['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium']); // Social sites
var videoWindow = new Window(['Netflix', 'YouTube', 'Vimeo', 'Vine']); //  Entertainment sites

// Now perform the tab opening, closing, and other operations
var finalTabs = socialWindow
                    .tabOpen() // Open a new tab for cat memes
                    .join(videoWindow.tabClose(2)) // Close third tab in video window, and join
                    .join(workWindow.tabClose(1).tabOpen());

alert(finalTabs.tabs);
```

Add a user-defined map and filter prototypes methods to the global Array object: 
```
var s = [23, 65, 98, 5];

Array.prototype.myMap = function(callback){
  var newArray = [];
  for(let i = 0; i < this.length; i++) {
    newArray.push(callback(this[i]));
  }
  // the forEach method also works 
  // this.forEach(a => newArray.push(callback(a)));
  return newArray;
};

var new_s = s.myMap(function(item){
  return item * 2;
});

Array.prototype.myFilter = function(callback){
  var newArray = [];
  // Add your code below this line
  this.forEach(el => {if (callback(el)) {
      newArray.push(el);
    }
  });
  // Add your code above this line
  return newArray;
};
```

### filter
`.filter` method takes a callback function input and returns elements in a new array if it evaluates to true
The following code chunk works, but it won't work if we wrap {} around the arrown function in .filter.  Why is that?
```
var filteredList = watchList.filter(el => parseInt(el.imdbRating) >= 8).map(el => {return {title: el.Title, rating: el.imdbRating}});
```

### concat
+ `.concat` allows us to push items to the end of an array in a non mutating way. 

### reduce
The array `.reduce` methods takes simplifies an into an object of length one based on a callback function. The `a and b` inputs to the function are `arr[0]` and `arr[1]` on the first call, then the result of the first call and `arr[2]` on the second call, etc. 
```
var nolan_movies = watchList.filter(el => el.Director === 'Christopher Nolan');
var averageRating = nolan_movies.map(el => parseFloat(el.imdbRating)).reduce((a, b) => a + b)/(nolan_movies.length);
```
  
### Sorting examples
Sorting defaults to unicode which converts numbers to characters.  We need callback functions to sort numeric values correctly.  Sort also mutates the original array.  
```
function ascendingOrder(arr) {
  return arr.sort(function(a, b) {
    return a - b;
  });
}
ascendingOrder([1, 5, 2, 3, 4]);

function reverseAlpha(arr) {
  return arr.sort(function(a, b) {
    return a < b;
  });
}
reverseAlpha(['l', 'h', 'z', 'b', 's']);
```

### join  
The array `.join('delimiter')` method joins elements of an array using a delimiter
```
['hello', 'world'].join(' ');
```

### every / some
The `.every` method takes a callback function and checks if every value is true. The `.some` method (any in R) method checks if any applications of the callback function are true
    
**Curry and Partial Application:**
+ `arity` is the number of arguments a function requires
+ `currying` a function means converting one function of N arity (arguments) into N functions of arity 1.  
+ partial application can be described as applying a few arguments to a function at a time and returning another function that is applied to more arguments
    + this basically looks like big nested function calls (pretty weird)
```
function add(x) {
  return function(y) {
    return function(z) {
      return x + y + z;
    }
  }
}
add(10)(20)(30);
```
<hr> 


## Intermediate Algorithm Scripting 

1. Create a `range` function for an unsorted 2-number array that sums all numbers (inclusive).
```
function sumAll(arr) {
  var sortedArr = arr.sort((a,b) => a-b);
  var firstNum = arr[0];
  var lastNum = arr[1];
  // Using Arithmetic Progression summing formula
  var sum = (lastNum - firstNum + 1) * (firstNum + lastNum) / 2;
  return sum;
}
```
2. Compare two arrays and return a new array with any items only found in one of the two given arrays, but not both. In other words, return the symmetric difference of the two arrays.
- Could use a nested for loop
- Could decompose into one array then check for duplicates
- My solution: 
```
function diffArray(arr1, arr2) {
  return [...arr1, ...arr2].filter(el => !(arr1.includes(el) && arr2.includes(el)));
}
```
3. You will be provided with an initial array (the first argument in the destroyer function), followed by one or more arguments. Remove all elements from the initial array that are of the same value as these arguments.
- solution was required to use the `arguments` object 
- `arguments` is not an array and only has the `length` property
- we use `Array.from` to convert `arguments` to an array. 
```
function destroyer(arr) {
  let destroyers = Array.from(arguments).splice(1);
  return arguments[0].filter(el => !(destroyers.includes(el)));
}
destroyer([1, 2, 3, 1, 2, 3], 2, 3);
```

4. Translate the provided string to pig latin. Pig Latin takes the first consonant (or consonant cluster) of an English word, moves it to the end of the word and suffixes an "ay". If a word begins with a vowel you just add "way" to the end.
```
function translatePigLatin(str) {
  if (str.split('')[0].match(/[aeiou]/) !== null) {
    return str + 'way';
  } 
  let chars = str.match(/[^aeiou]+/).toString().split('');
  return (str.split('').splice(chars.length).join('') + chars.join('') + 'ay');
}
translatePigLatin("consonant");
```

5. Convert a string to spinal case. Spinal case is all-lowercase-words-joined-by-dashes.
- split string on all non alphabet characters 
- join string on dashes 
  
6. Perform a search and replace on the sentence using the arguments provided and return the new sentence. Preserve the case of the first character in the original word when you are replacing it. For example if you mean to replace the word "Book" with the word "dog", it should be replaced as "Dog". 
- match pattern and extract (case insensitive regex)
- if you need to pass a variable to create a regex expression use: `var regex = new RegExp(variable, "i")`
- check for caps using str === str.toLowerCase()
- if true then replace, if false capitalize then replace

```
function myReplace(str, before, after) {
  var regex = new RegExp(before, "i"); 
  var out = str.match(regex).toString(); 
  if (out === before.toLowerCase()) {
    return str.replace(regex, after);
  } else {
    let arr = after.split('')
    var firstLetter = arr.shift().toUpperCase();
    arr.unshift(firstLetter); 
    var afterCapitalized = arr.join('');
    return str.replace(regex, afterCapitalized);
  }
}
myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");

// Cool alternate solution to uppercase matching and string mutations.
//Check whether the first letter is uppercase or not
  if(/[A-Z]/.test(before[0])){
  //Change the word to be capitalized
    after = after.charAt(0).toUpperCase()+after.slice(1);
}
```

7. The DNA strand is missing the pairing element. Take each character, get its pair, and return the results as a 2d array.
- create a hashmap object with all pairs 
- split string into array, then map to a 2-D array returning each element + its hashmap lookup
```
function pairElement(str) {
  const hashmap = {
    A: 'T',
    T: 'A', 
    C: 'G',
    G: 'C'
  }
  let dna = str.split('');
  return dna.map(el => [el, hashmap[el]])
}
pairElement("GCG");
```

8. Find the missing letter in the passed letter range and return it. If all letters are present in the range, return undefined.
- want to avoid using a for loop 
- decompose the input string to an array
- loop through each entry, if it matches return true and push the element onto a regex exp
- when it returns false we return that letter

```
function fearNotLetter(str) {
  const alphabet = "abcdefghijklmnopqrstuvwxyz"; 
  let letters = str.split('');
  for (let i=0; i < letters.length; i++) {
    var regex = new RegExp(letters.slice(0,i+1).join(''))
    if (!alphabet.match(regex)) {
      return letters[i];
    }
  }

  return undefined;
}
fearNotLetter("abce");
```

9. Check if the predicate (second argument) is truthy on all elements of a collection (first argument). In other words, you are given an array collection of objects. The predicate pre will be an object property and you need to return true if its value is truthy. Otherwise, return false.
- use the Boolean function to convert to true/false
- select values in object using []

```
function truthCheck(collection, pre) {
  return collection.map(el => Boolean(el[pre])).every(el => el === true);
}
truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");
```

10. Create a function that sums two arguments together. If only one argument is provided, then return a function that expects one argument and returns the sum. For example, addTogether(2, 3) should return 5, and addTogether(2) should return a function. Calling this returned function with a single argument will then return the sum: var sumTwoAnd = addTogether(2); sumTwoAnd(3) returns 5.
- need to use the `arguments object for this` 
- if it's length 2 return the sum 
- if it's length 1 return a function 
- my solution ended up looking terrible:

```
function addTogether(arg1, arg2) {
  if (!(typeof arg1 === 'number')) {
    return undefined; 
  } 
    if (arguments.length === 2) {
      if (typeof arg2 === 'number') {
        return arguments[0] + arguments[1];
      } else {
        return undefined;
      }
    }
    if (arguments.length === 1) {
       return function(y) {
         if (typeof y === 'number') {
           return arg1 + y;
         } else {
           return undefined;
         }
       } 
    }
    return undefined; 
}
addTogether(2,3);
```
- try to improve on it before reading more solutions
- use a function to check the typeof the args

11. Write a function that takes two or more arrays and returns a new array of unique values in the order of the original provided arrays.
- the first array always stays the same 
- combine the next arguments into one (here use .splice and .reduce to create one array)
- if the first array doesn't contain an argument the .push it into that array. 
- use forEach so we don't return an array? 

```
function uniteUnique() {
  let unique = arguments[0];
  let numbers = Array.from(arguments).splice(1).reduce((a,b) => [...a, ...b]);
  console.log(numbers); // see what this looks like
  numbers.forEach(el => { 
    if (!(unique.includes(el)))
      unique.push(el);
  })
  return unique;
}
uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
```

12. Convert the characters &, <, >, " (double quote), and ' (apostrophe), in a string to their corresponding HTML entities.
- create a hashmap
- then use str.split, map, and join 
```
function convertHTML(str) {
  const hashmap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  }
  return str.split('').map(el => {return hashmap[el] ? hashmap[el] : el;}).join('');
}
convertHTML("Dolce & Gabbana");
```

13. Given a positive integer num, return the sum of all odd Fibonacci numbers that are less than or equal to num. The first two numbers in the Fibonacci sequence are 1 and 1. Every additional number in the sequence is the sum of the two previous numbers. The first six numbers of the Fibonacci sequence are 1, 1, 2, 3, 5 and 8.
- create the fibonacci sequence 
- go through and use .reduce() to sum it for odd entries
- might need to use filter first to get rid of even entries 
```
function sumFibs(num) {
  let arr = [1, 1]
  while (arr.slice(-1) < num) {
    arr.push(arr.slice(-2).reduce((a, b) => a+b));
  }
  arr.slice(-1) > num ? arr.pop() : 'do nothing';
  return arr.filter(el => el % 2 !== 0).reduce((a, b) => a+b);
}
console.log(sumFibs(15));
```

14. Return an English translated sentence of the passed binary string. The binary string will be space separated. 
- split into an array on whitespace 
- convert the binary string to its decimal value using parseInt(, 2)
- retrieve the ASCII decimal value using the string method: `String.fromCharChode()`
```
function binaryAgent(str) {
  return str.split(' ').map(el => String.fromCharCode(parseInt(el, 2))).join('');
}
console.log(binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"));
```

15. Given the array arr, iterate through and remove each element starting from the first element (the 0 index) until the function func returns true when the iterated element is passed through it. Then return the rest of the array once the condition is satisfied, otherwise, arr should be returned as an empty array. 
```
dropElements([1, 2, 3, 4], function(n) {return n >= 3;}) should return [3, 4]
```
- makes sense to use a for loop 
- could also try using filter (doesn't make sense because we return on the first true)
- in the for loop I made a OBOE initially because i was checking function(arr[i]) - but if it was false then I shifted off the first element - modifying the input array.  Then the next iteration of the loop, arr[1], was actually the third element because the first one was shifted off. 
- used a while loop instead of a for loop
```
function dropElements(arr, func) {
  while (!func(arr[0])) {
    arr.shift();
  }
  return arr; 
}
console.log(dropElements([1, 2, 3], function(n) {return n < 3; }));
console.log(dropElements([1, 2, 3, 4], function(n) {return n >= 3;}));
console.log(dropElements([0, 1, 0, 1], function(n) {return n === 1;}));
```

16. Fill in the object constructor with the following methods below: getFirstName() getLastName() getFullName() setFirstName(first) setLastName(last) setFullName(firstAndLast). 

```
var Person = function(input) {
  var arr = input.split(' ');
  // Complete the method below and implement the others similarly
  this.getFullName = function() {
    return arr.join(' ');
  };

  this.getFirstName = function() {
    return arr[0];
  };

  this.getLastName = function() {
    return arr[1];
  };

  this.setFirstName = function(input) {
    arr[0] = input;
  };

  this.setLastName = function(input) {
    arr[1] = input;
  }

  this.setFullName = function(input) {
    arr = input.split(' ');
  }
};

var bob = new Person('Bob Ross');
bob.getFullName();
```

17. Return a new array that transforms the elements' average altitude into their orbital periods (in seconds). The array will contain objects in the format {name: 'name', avgAlt: avgAlt}. You can read about orbital periods on Wikipedia. The values should be rounded to the nearest whole number. The body being orbited is Earth. The radius of the earth is 6367.4447 kilometers, and the GM value of earth is 398600.4418 km3s-2.
- create an obortial period class constructor 
- it takes in the satellites name and avgAlt and returns an object with name and orbital period 
- I could've also looped through the array, calculated period for each object, and deleted the avgAlt prop from each one.  

```
function orbitalPeriod(arr) {
  function calculatePeriod(altitude) {
    var GM = 398600.4418;
    var earthRadius = 6367.4447;
    var radius = earthRadius + altitude; 
    return Math.round(2*Math.PI*Math.sqrt(Math.pow(radius, 3)/GM));
  }

  function orbitalPeriod(name, avgAlt) {
    return {name: name, orbitalPeriod: calculatePeriod(avgAlt)};
  }

  return arr.map(el => orbitalPeriod(el['name'], el['avgAlt']));
}
console.log(orbitalPeriod([{name : "sputnik", avgAlt : 35873.5553}]));
```

## Project 2: Roman Numerals
Roman Numeral Converter. Convert the given number into a roman numeral. All [roman numerals](https://www.mathsisfun.com/roman-numerals.html) answers should be provided in upper-case.
- initially thought of writing four functions: one each of the places: ones, tens, hundreds, and thousands columns.  
- then I realized the body of these functions would be the same: except for the characters it assigns 
- we can combine then into one function that takes two inputs: a number (0-9) and a character array of roman numerals or "rules" to assign.  

```
function convertToRoman(num) {
  var numbers = num.toString().split('').reverse().map(el => parseInt(el));
  var romanNumerals = [['I', 'V', 'X'], ['X', 'L', 'C'],
                      ['C', 'D', 'M'], ['M', 'Vbar', 'Xbar']];
  var inputs = [];
  for (let i = 0; i < numbers.length; i++) {
      inputs[i] = [numbers[i], romanNumerals[i]];
  }

  var replaceWithRoman = function(num, romanNumerals) {
     let out; 
     switch(true) {
        case num == 0:
            out = '';
            break;
        case num <= 3:
            out = romanNumerals[0].repeat(num);
            break;
        case num == 4:
            out = romanNumerals[0] + romanNumerals[1];
            break;
        case num <= 8:
            out = romanNumerals[1] + romanNumerals[0].repeat(num-5);
            break;
        case num == 9: 
            out = romanNumerals[0] + romanNumerals[2];
            break;
     }
     return out;
 }
 return inputs.map(el => replaceWithRoman(el[0], el[1])).reverse().join('')
}
console.log(convertToRoman(36));
console.log(convertToRoman(400));
console.log(convertToRoman(1000));
```