  # Front End Libraries 
These are my notes from the Front End Libraries [certification](https://learn.freecodecamp.org/front-end-libraries/bootstrap) from FreeCodeCamp! 

## Bootstrap 
Bootstrap is a front-end framework used to design responsive web pages and web applications. It takes a mobile-first approach to web development. Bootstrap includes pre-built CSS styles and classes, plus some JavaScript functionality. Bootstrap uses a responsive 12 column grid layout and has design templates for: buttons, images, tables, forms, and navigation.
  
Bootstrap will figure out how wide your screen is and respond by resizing your HTML elements - hence the name Responsive Design. 

### Add bootstrap 
You can add bootstrap by adding this code snippet to the top of your HTML
```
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"/>
```

### Bootstrap classes
class | explanation 
------------------------- | ---------------------------------------------------------
`class = img-responsive` |  make an image fit exactly the width of your screen.
`class = text-center` | center text 
`text-primary` | 
`img-responsive` | 
`form-control` | 
`btn-default` | applies border radius 
`btn btn-primary` | applies border-radius, blue background, and white text styling
`div class='well'` | creates a perception of depth 

### Buttons 
Bootstrap has default button styles that look better than normal ones.  
```
<button class="btn btn-default">Submit</button>
```
If we add the `btn-block` class it will expand to fill the horizontal space and any elements that follow it will be pushed to a new line. 
```
<button class="btn btn-default btn-block">Submit</button>
```
The `btn-primary` class is the main color you'll use in your app.  We use this in place of `btn-default`
The `btn-info` is another color scheme that calls attention to the user. (lighter blue)
The `btn-danger` class provides a red styling - warns of a destructive action like deleting.  


### BootStrap Grid 
Bootstrap uses a responsive 12-column grid system, which makes it easy to put elements into rows and specify each element's relative width. Most of Bootstrap's classes can be applied to a div element. Bootstrap has different column width attributes that it uses depending on how wide the user's screen is. For example, phones have narrow screens, and laptops have wider screens.Take for example Bootstrap's `col-md-*` class. Here, md means medium, and * is a number specifying how many columns wide the element should be. In this case, the column width of an element on a medium-sized screen, such as a laptop, is being specified.

+ This example creates a 3 column row.  `xs` refers to extra small - for phone screens.  4 refers to the number of columns each `div` spans.  
```
 <div class='row'>
  <div class='col-xs-4'><button class="btn btn-block btn-primary">Like</button></div>
  <div class='col-xs-4'><button class="btn btn-block btn-info">Info</button></div>
  <div class='col-xs-4'><button class="btn btn-block btn-danger">Delete</button></div>
</div>
```

+ Bootstrap's responsive system will resize images so that they fit on the same line. (Remove the bootstrap classes from the following html to see the effect) 
```
<div class='row'>
  <div class='col-xs-8'><h2 class="text-primary text-center">CatPhotoApp</h2></div>
  <div class='col-xs-4'><a href="#"><img class="img-responsive thick-green-border" src="https://bit.ly/fcc-relaxing-cat" alt="A cute orange cat lying on its back."></a></div>
</div>
```

+ We can also nest radio buttons in a responsive layout 

```
 <div class='row'>
    <div class='col-xs-6'><label><input type="radio" name="indoor-outdoor"> Indoor</label></div>
    <div class='col-xs-6'><label><input type="radio" name="indoor-outdoor"> Outdoor</label></div>
    <div class='col-xs-6'><label><input type="checkbox" name="personality"> Loving</label></div>
    <div class='col-xs-6'><label><input type="checkbox" name="personality"> Lazy</label></div>
    <div class='col-xs-6'><label><input type="checkbox" name="personality"> Crazy</label></div>
  </div>
```

### span 
We can use a `<span>` element to create styles for inline elements. We then assign a class to the span to apply styling.   
```
.text-danger {
  color: red;
}
<p>Things cats <span class='text-danger'>love:</span></p>
```

### Font awesome
Font Awesome is a convenient library of icons. These icons are vector graphics, stored in the .svg (scalable vector graphic) file format. These icons are treated just like fonts. You can specify their size using pixels, and they will assume the font size of their parent HTML elements. You need to include the link to the Font awesome style sheet in the `<head>` element to use the icons. 
```
<i class="fa fa-info-circle"></i>
```

+ You can also use a `span` tag for FA icons: 
```
<span class='fa fa-info-circle'></span>
```

+ You can also put icons in buttons for added effect: 
```
<button class="btn btn-block btn-primary"><i class="fa fa-thumbs-up"></i> Like</button>
```

### Create a bootstrap layout. 
To create a responsive layout elements need to be wrapped in `div class='container-fluid></div>`.  You then use row and column classess to create desired layouts. 
```
<div class="row">
  <div class="col-xs-6">
  </div>
  <div class="col-xs-6">
  </div>
</div>
```

### Class targeting 
Sometimes we apply classes to html elements without any CSS styling to select them easie when using jQuery. Here we add the "target" class with no styling.   
```
<button class="btn btn-default target"></button>
```

<hr>

## jQuery
jQuery is one of the many libraries for JavaScript. It is designed to simplify scripting done on the client side. jQuery's most recognizable characteristic is its dollar sign ($) syntax. With it, you can easily manipulate elements, create animations and handle input events.

Add the following code to the top of the HTML document to initialize jQuery: 
```
<script>$(document).ready(function() {
});
</script>
```

### Methods 
#### selector 
All jQuery functions start with a $, usually referred to as a dollar sign operator, or as bling.
jQuery often selects an HTML element with a selector, then does something to that element. For example, let's make all of the button elements bounce. 
```
<script>
  $(document).ready(function() {
  $("button").addClass("animated bounce");
  });
</script>
```

We can target a classes and ids by using the same `.` and `#` syntax: 
```
$('.class-name').addClass('animated shake');
$("#target3").addClass("animated fadeOut");
```

#### Change CSS
We can change the CSS of an element by using the `.css()` function. 
```
$('#target1').css('color', 'blue');
``` 

#### Change properties
jQuery has a function called `.prop()` that allows you to adjust the properties of elements.
Here's how you would disable all buttons:
```
$("button").prop("disabled", true);
```

#### Change text inside elements
jQuery has a function called `.html()` that lets you add HTML tags and text within an element. Any content previously within the element will be completely replaced with the content you provide using this function.
```
$("h3").html("<em>jQuery Playground</em>");
```
jQuery also has a similar function called .text() that only alters text without adding tags. In other words, this function will not evaluate any HTML tags passed to it, but will instead treat it as the text you want to replace the existing content with.


#### remove elements 
We can remove elements by using the `.remove()` function. 
```
$('#target4').remove();
```

#### move elements
jQuery has a function called `appendTo()` that allows you to select HTML elements and append them to another element.
```
$('.class').appendTo('#id')
```

#### clone elements 
jQuery has a function called `clone()` that makes a copy of an element. We can use this in conjunction with `appendTo()` to copy-paste elements 
```
$('#id').clone().appendTo('.class')
```

#### parent function
jQuery has a function called `parent()` that accesses the parent of the selected element.  This examples changes the parent's background color 
```
$('.class').parent().css('background-color', 'blue)
```

#### children function 
jQuery has a function called `children()` that allows you to access the children of whichever element you've selected.
```
$("#left-well").children().css("color", "blue")
```

#### CSS Selectors 
jQuery uses CSS Selectors to target elements. The `target:nth-child(n)` CSS selector allows you to select all the nth elements with the target class or element type. NOTE: you don't select the parent element - you specify the class you're targeting and nth-child specifies what index you want.  A better name for this would be `nth-index`.  NOTE: this will also select that index for every grouping of these classes.  If, for instance, there are two lists and you want the second item, this will select the second item in BOTH lists.  
```
$(".target:nth-child(3)").addClass("animated bounce");
```
We can also target even or odd elements (based on index) with similar syntax: 
```
$(".target:odd").addClass("animated shake");
```

#### Hilarious page animation 
```
    $('body').addClass('animated hinge')
```

## SaSS 
Sass, or "Syntactically Awesome StyleSheets", is a language extension of CSS. It adds features that aren't available using basic CSS syntax. Sass makes it easier for developers to simplify and maintain the style sheets for their projects.

Sass can extend the CSS language because it is a preprocessor. It takes code written using Sass syntax, and converts it into basic CSS. This allows you to create variables, nest CSS rules into others, and import other Sass files, among other things. The result is more compact, easier to read code.

There are two syntaxes available for Sass. The first, known as SCSS (Sassy CSS) and used throughout these challenges, is an extension of the syntax of CSS. This means that every valid CSS stylesheet is a valid SCSS file with the same meaning. Files using this syntax have the .scss extension.

The second and older syntax, known as the indented syntax (or sometimes just "Sass"), uses indentation rather than brackets to indicate nesting of selectors, and newlines rather than semicolons to separate properties. Files using this syntax have the .sass extension.


+ We can create variables in SaSS with the `$` and set their values. 

```
$main-fonts: Arial, sans-serif;
$headings-color: green;
h1 {
  font-family: $main-fonts;
  color: $headings-color;
}
```

+ We can nest multiple CSS rules inside their parent elements 

```
nav {
  background-color: red;

  ul {
    list-style: none;

    li {
      display: inline-block;
    }
  }
}
```

### mixin
mixins are like functions for CSS.  Here is the syntax for defining one: 
```
@mixin box-shadow($x, $y, $blur, $c){ 
  -webkit-box-shadow: $x, $y, $blur, $c;
  -moz-box-shadow: $x, $y, $blur, $c;
  -ms-box-shadow: $x, $y, $blur, $c;
  box-shadow: $x, $y, $blur, $c;
}
```
Now any time a box-shadow rule is needed, only a single line calling the mixin replaces having to type all the vendor prefixes. A mixin is called with the `@include` directive:
```
div {
  @include box-shadow(0px, 0px, 4px, #fff);
}
```

```
  @mixin border-radius($radius){
    -webkit-border-radius: $radius;
    -moz-border-radius: $radius;
    -ms-border-radius: $radius;
    border-radius: $radius;
  }
```

+ we can also create if/else statements with `@if` and `@else`

```
  @mixin border-stroke($val) {
    @if $val == light {
      border: 1px solid black;
    } @else if $val == medium {
      border: 3px solid black;
    } @else if $val == heavy {
      border: 6px solid black;
    } @else {
      border: none;
    }
  }
```

### for loop
+ `@for` is used in two ways: "start through end" or "start to end". The main difference is that "start to end" excludes the end number, and "start through end" includes the end number.
Example: 
```
@for $i from 1 through 12 {
  .col-#{$i} { width: 100%/12 * $i; }
}
```
Here's what it looks like when it's converted to CSS:

```
.col-1 {
  width: 8.33333%;
}

.col-2 {
  width: 16.66667%;
}

...
.col-12 {
  width: 100%;
}
```

### each 
Same concept as for loop except you can define specific values - this is useful for colors

```
@each $color in blue, red, green {
  .#{$color}-text {color: $color;}
}
```

### while 
Apparently these can break style sheets reeally easily - be sure to define the end clause FIRST.
```
$x: 1;
@while $x < 13 {
  .col-#{$x} { width: 100%/12 * $x;}
  $x: $x + 1;
}
```

### Partials 
Partials in Sass are separate files that hold segments of CSS code. These are imported and used in other Sass files. This is a great way to group similar code into a module to keep it organized.

Names for partials start with the underscore (_) character, which tells Sass it is a small segment of CSS and not to convert it into a CSS file. Also, Sass files end with the .scss file extension. To bring the code in the partial into another Sass file, use the `@import` directive.

For example, if all your mixins are saved in a partial named "_mixins.scss", and they are needed in the "main.scss" file, this is how to use them in the main file:

```
// In the main.scss file
@import 'mixins'
```

### extend 
We can import the properties from one class to another class if we wish to add on (gets rid of excessive copy-pasting)

```
.panel{
  background-color: red;
  height: 70px;
  border: 2px solid green;
}

.big-panel{
  @extend .panel;
  width: 150px;
  font-size: 2em;
}
```

<hr>


## React 
React, popularized by Facebook, is an open-source JavaScript library for building user interfaces. It is used to create components, handle state and props, utilize event listeners and certain life cycle methods to update data as it changes. React combines HTML with JavaScript functionality to create its own markup language, JSX. This section will introduce you to all of these concepts and how to implement them for use with your own projects.
  
Intro: React is an Open Source view library created and maintained by Facebook. It's a great tool to render the User Interface (UI) of modern web applications.
  
React uses a syntax extension of JavaScript called JSX that allows you to write HTML directly within JavaScript. This has several benefits. It lets you use the full programmatic power of JavaScript within HTML, and helps to keep your code readable. For the most part, JSX is similar to the HTML that you have already learned, however there are a few key differences that will be covered throughout these challenges.
  
For instance, because JSX is a syntactic extension of JavaScript, you can actually write JavaScript directly within JSX. To do this, you simply include the code you want to be treated as JavaScript within curly braces: { 'this is treated as JavaScript code' }. Keep this in mind, since it's used in several future challenges.
  
However, because JSX is not valid JavaScript, JSX code must be compiled into JavaScript. The transpiler Babel is a popular tool for this process. For your convenience, it's already added behind the scenes for these challenges. If you happen to write syntactically invalid JSX, you will see the first test in these challenges fail.
  
It's worth noting that under the hood the challenges are calling `ReactDOM.render(JSX, document.getElementById('root'))`. This function call is what places your JSX into React's own lightweight representation of the DOM. React then uses snapshots of its own DOM to optimize updating only specific parts of the actual DOM.  

### Complex element 
Elements must be transpiled as single elements.  Therefore if you have multiple elements they must be wrapped in a single parent element. The following is invalid JSX (it needs to be wrapped in a `div` parent): 
```
<p>Paragraph One</p>
<p>Paragraph Two</p>
<p>Paragraph Three</p>
```
We can optionally wrap these declarations in parentheses - though it is considered good practice to do so. 

### Comments 
To add comments we use the following syntax: `{/* */}`

### Render HTML elements to the DOM
ReactDOM.render(componentToRender, targetNode), where the first argument is the React element or component that you want to render, and the second argument is the DOM node that you want to render the component to.
```
const JSX = (
  <div>
    <h1>Hello World</h1>
    <p>Lets render this to the DOM</p>
  </div>
);
ReactDOM.render(JSX, document.getElementById('challenge-node'));
```

### Classes in JSX 
These declarations are slightly different because "class" is a reserved word in JS.  Instead we use "className" to define classes in JSX. The naming convention switches to camel case also - onclick becomes onClick, onchange to onChange, etc. 
```
const JSX = (
  <div className='myDiv'>
    <h1>Add a class to this div</h1>
  </div>
);
```

### Self-closing tags
In html we can use some elements that don't include a closing tag like `<br>`.  In JSX all elements must either be followed by a closing tag or be written in self-closing format `<br>` --> `<br />`.  n JSX, the rules are a little different. Any JSX element can be written with a self-closing tag, and every element must be closed. The line-break tag, for example, must always be written as <br /> in order to be valid JSX that can be transpiled. A <div>, on the other hand, can be written as <div /> or <div></div>. The difference is that in the first syntax version there is no way to include anything in the <div />. You will see in later challenges that this syntax is useful when rendering React components.
```
const JSX = (
  <div>
    <h2>Welcome to React!</h2> <br />
    <p>Be sure to close all tags!</p>
    <hr />
  </div>
);
```

### Components 
Components are the core of React. Everything in React is a component. There are two ways to create a React component. The first way is to use a JavaScript function. Defining a component in this way creates a stateless functional component. A stateless component is one that can **receive data and render it, but does not manage or track changes to that data**. To create a component with a function, you simply write a JavaScript function that returns either JSX or null. One important thing to note is that React requires your function name to begin with a capital letter.
  
Because a JSX component represents HTML, you could put several components together to create a more complex HTML page. This is one of the key advantages of the component architecture React provides. It allows you to compose your UI from many separate, isolated components. This makes it easier to build and maintain complex user interfaces.
```
const MyComponent = function() {
  // change code below this line
  return (
    <div>dummy text</div>
  );
}
```

#### Create a componenet with ES6 syntax 
```
class Kitten extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <h1>Hi</h1>
    );
  }
}
```
This creates an ES6 class Kitten which extends the React.Component class. So the Kitten class now has access to many useful React features, such as local state and lifecycle hooks.
  
Also notice the Kitten class has a constructor defined within it that calls super(). It uses super() to call the constructor of the parent class, in this case React.Component. The constructor is a special method used during the initialization of objects that are created with the class keyword. It is best practice to call a component's constructor with super, and pass props to both. This makes sure the component is initialized properly.

#### Composition
We can put multiple components together into one - for instance navbar, dashboard, and footer components.  To compose then together we create a parent component that calls then.  They are called using self-closing JSX tag syntax. When React encounters a custom HTML tag that references another component (a component name wrapped in < /> like in this example), it renders the markup for that component in the location of the tag.
```
return (
<App>
  <Navbar />
  <Dashboard />
  <Footer />
</App>
)
```

+ More extensive example: 

```
const ChildComponent = () => {
  return (
    <div>
      <p>I am the child</p>
    </div>
  );
};

class ParentComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>I am the parent</h1>
          <ChildComponent />
      </div>
    );
  }
};
```

+ Even more extensive example: 

```
const TypesOfFruit = () => {
  return (
    <div>
      <h2>Fruits:</h2>
      <ul>
        <li>Apples</li>
        <li>Blueberries</li>
        <li>Strawberries</li>
        <li>Bananas</li>
      </ul>
    </div>
  );
};

const Fruits = () => {
  return (
    <div>
      <TypesOfFruit />
    </div>
  );
};

class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
          <Fruits />
      </div>
    );
  }
};
```

#### Render components 
React components are passed into `ReactDOM.render()` a little differently than JSX elements. For JSX elements, you pass in the name of the element that you want to render. However, for React components, you need to use the same syntax as if you were rendering a nested component, for example `ReactDOM.render(<ComponentToRender />, targetNode)`. You use this syntax for both ES6 class components and functional components.

#### Props to StateLess functional Component
In React, you can pass props, or properties, to child components. Say you have an App component which renders a child component called `Welcome` that is a stateless functional component. You can pass `Welcome` a user property by writing:
```
<App>
  <Welcome user='Mark' />
</App>
```
You use custom HTML attributes that React provides support for to pass the property `user` to the component `Welcome`. Since `Welcome` is a stateless functional component, it has access to this value like so.  In this example `Welcome` is also a component. 
```
const Welcome = (props) => <h1>Hello, {props.user}!</h1>
```

+ Example (pass information from a parent to a child through props): 
In this example we pass in the property (like passing in an argument to a function) like this `<CurrentDate date={Date()}/>`. Then in the child component we access its date property that we passed in like this: `<p>The current date is: {props.date}</p>`
```
const CurrentDate = (props) => {
  return (
    <div>
      { /* change code below this line */ }
      <p>The current date is: {props.date}</p> {/*THIS IS LIKE FUNCTION BODY*/}
      { /* change code above this line */ }
    </div>
  );
};

class Calendar extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h3>What date is it?</h3>
        { /* change code below this line */ }
        <CurrentDate date={Date()}/>  {/*THIS IS LIKE A FUNCTION CALL + ARGUMENT INPUTS*/}
        { /* change code above this line */ }
      </div>
    );
  }
};
```

+ Pass an array in as a prop.  We can call methods in the child component, in this case we call `join`

```
const List= (props) => {
  { /* change code below this line */ }
  return <p>{props.tasks.join(", ")}</p>
  { /* change code above this line */ }
};

class ToDo extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>To Do Lists</h1>
        <h2>Today</h2>
        { /* change code below this line */ }
        <List tasks={['hackathon', 'React', 'exercise']}/>
        <h2>Tomorrow</h2>
        <List tasks={['gym', 'redux', 'eat']}/>
        { /* change code above this line */ }
      </div>
    );
  }
};
```

#### Default Props 
We can set default properties using the following syntax.  These are good for initial values. When we want to set numeric properties we have to wrap them in curly braces, this tells the browser to interpret them as javascript.  Ex: `return <Items quantity={10}/>`
```
const ShoppingCart = (props) => {
  return (
    <div>
      <h1>Shopping Cart Component</h1>
    </div>
  )
};
// change code below this line
ShoppingCart.defaultProps = {items: 0}
```

#### PropTypes
We can specify what kind of type a property should. If the wrong input is passed into it then it will throw a helpful warning. As of React v15.5.0, PropTypes is imported independently from React, like this: `import React, { PropTypes } from 'react';`
```
Items.defaultProps = {
  quantity: 0
};
Items.propTypes = {quantity: PropTypes.number.isRequired};
```

#### Props in ES6 class component
Anytime you refer to a class component within itself, you use the `this` keyword. To access props within a class component, you preface the code that you use to access it with `this`. For example, if an ES6 class component has a prop called data, you write {this.props.data} in JSX.  In a stateless function component you can just call `props.whatever`.  

+ Example: 

```
class ReturnTempPassword extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
            { /* change code below this line */ }
            <p>Your temporary password is: <strong>{this.props.tempPassword}</strong></p>
            { /* change code above this line */ }
        </div>
    );
  }
};

class ResetPassword extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
          <h2>Reset Password</h2>
          <h3>We've generated a new temporary password for you.</h3>
          <h3>Please reset this password from your account settings ASAP.</h3>
          { /* change code below this line */ }
            <ReturnTempPassword tempPassword='hellocow'/>
          { /* change code above this line */ }
        </div>
    );
  }
};
```


A stateless functional component is any function you write which accepts props and returns JSX. A stateless component, on the other hand, is a class that extends React.Component, but does not use internal state (covered in the next challenge). Finally, a stateful component is any component that does maintain its own internal state. You may see stateful components referred to simply as components or React components.

A common pattern is to try to minimize statefulness and to create stateless functional components wherever possible. This helps contain your state management to a specific area of your application. 

### State
State consists of any data your application needs to know about, that can change over time. You want your apps to respond to state changes and present an updated UI when necessary. You create state in a React component by declaring a `stat`e property on the component class in its constructor. This initializes the component with state when it is created. The state property must be set to a JavaScript object. Declaring it looks like this:

```
class StatefulComponent extends React.Component {
  constructor(props) {
    super(props);
    // initialize state here
    this.state = {
      name: 'Dom'
    }
  }
  render() {
    return (
      <div>
        <h1>{this.state.name}</h1>
      </div>
    );
  }
};
```

+ Longer Defintion of State: 

Once you define a component's initial state, you can display any part of it in the UI that is rendered. If a component is stateful, it will always have access to the data in state in its render() method. You can access the data with this.state.
  
If you want to access a state value within the return of the render method, you have to enclose the value in curly braces.
  
State is one of the most powerful features of components in React. It allows you to track important data in your app and render a UI in response to changes in this data. If your data changes, your UI will change. React uses what is called a virtual DOM, to keep track of changes behind the scenes. **When state data updates, it triggers a re-render of the components using that data - including child components that received the data as a prop.** React updates the actual DOM, but only where necessary. This means you don't have to worry about changing the DOM. You simply declare what the UI should look like.
  
Note that if you make a component stateful, no other components are aware of its state. Its state is completely encapsulated, or local to that component, unless you pass state data to a child component as props. This notion of encapsulated state is very important because it allows you to write certain logic, then have that logic contained and isolated in one place in your code.

#### Access state with JS variables 
In component functions we can also access state in intermediate variables.  We can then call these variables in JSX using the curly brace syntax and the intermediate variable names. 

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'freeCodeCamp'
    }
  }
  render() {
    // change code below this line
    const name = this.state.name
    // change code above this line
    return (
      <div>
        { /* change code below this line */ }
          <h1>{name}</h1>
        { /* change code above this line */ }
      </div>
    );
  }
};
```

#### Update state 
You call the `setState` method within your component class like so: this.setState(), passing in an object with key-value pairs. The keys are your state properties and the values are the updated state data.

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'Initial State'
    };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    // change code below this line
    this.setState({
      name: 'React Rocks!'
    })
    // change code above this line
  }
  render() {
    return (
      <div>
        <button onClick={this.handleClick}>Click Me</button>
        <h1>{this.state.name}</h1>
      </div>
    );
  }
};
```

#### Add Methods 
A class method typically needs to use the `this` keyword so it can access properties on the class (such as `state` and `props`) inside the scope of the method. One common way is to explicitly bind `this` in the constructor so `this` becomes bound to the class methods when the component is initialized. TLDR: When we define methods for a react component we need to bind `this` to them in the constructor so they have access to the right "this". 

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      itemCount: 0
    };
    // change code below this line
    this.addItem = this.addItem.bind(this);
    // change code above this line
  }
  addItem() {
    this.setState({
      itemCount: this.state.itemCount + 1
    });
  }
  render() {
    return (
      <div>
        { /* change code below this line */ }
        <button onClick={this.addItem}>Click Me</button>
        { /* change code above this line */ }
        <h1>Current Item Count: {this.state.itemCount}</h1>
      </div>
    );
  }
};
```

#### Use State to Toggle and Element
You can use `state` in React applications in more complex ways than what you've seen so far. One example is to monitor the status of a value, then render the UI conditionally based on this value.

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      visibility: false
    };
    // change code below this line
    this.toggleVisibility = this.toggleVisibility.bind(this);
    // change code above this line
  }
  // change code below this line
  toggleVisibility() {
    this.setState({visibility: !this.state.visibility});
  }
  // change code above this line
  render() {
    if (this.state.visibility) {
      return (
        <div>
          <button onClick={this.toggleVisibility}>Click Me</button>
          <h1>Now you see me!</h1>
        </div>
      );
    } else {
      return (
        <div>
          <button onClick={this.toggleVisibility}>Click Me</button>
        </div>
      );
    }
  }
};
```

+ Another example using a counter to set state: 

```
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
    // change code below this line
    this.increment = this.increment.bind(this);
    this.decrement = this.decrement.bind(this);
    this.reset = this.reset.bind(this);
    // change code above this line
  }
  // change code below this line
  increment() {
    this.setState({count: this.state.count + 1})
  }
  decrement() {
    this.setState({count: this.state.count -1})
  }
  reset() {
    this.setState({count: 0})
  }
  // change code above this line
  render() {
    return (
      <div>
        <button className='inc' onClick={this.increment}>Increment!</button>
        <button className='dec' onClick={this.decrement}>Decrement!</button>
        <button className='reset' onClick={this.reset}>Reset</button>
        <h1>Current Count: {this.state.count}</h1>
      </div>
    );
  }
};
```

#### Controlled Input form 
Form control elements for text input, such as input and textarea, maintain their own state in the DOM as the user types --> as the user types their internal state gets updated (this makes sense).

#### Controlled Form 
When react controls the internal state of an html element - it is referred to as a controlled component.  
NEED TO COME BACK HERE AND FILL THIS OUT.

```
class MyForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: '',
      submit: ''
    };
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  handleChange(event) {
    this.setState({
      input: event.target.value
    });
  }
  handleSubmit(event) {
    // change code below this line
    event.preventDefault();
    this.setState({
      submit: this.state.input
    })
    // change code above this line
  }
  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          { /* change code below this line */ }
          <input value={this.state.input} onChange={this.handleChange}></input>
          { /* change code above this line */ }
          <button type='submit'>Submit!</button>
        </form>
        { /* change code below this line */ }
        <h1>{this.state.submit}</h1>
        { /* change code above this line */ }
      </div>
    );
  }
};
```

#### State in React 
This pattern illustrates some important paradigms in React. The first is unidirectional data flow. State flows in one direction down the tree of your application's components, from the stateful parent component to child components. The child components only receive the state data they need. The second is that complex stateful apps can be broken down into just a few, or maybe a single, stateful component. The rest of your components simply receive state from the parent as props, and render a UI from that state. It begins to create a separation where state management is handled in one part of code and UI rendering in another. This principle of separating state logic from UI logic is one of React's key principles. When it's used correctly, it makes the design of complex, stateful applications much easier to manage.  This must be how React and redux are combined ==> redux manages the one stateful component of the app. 

In this example `MyApp` is the component that manages state. When it renders Navbar we pass in `MyApp`'s name property as an argument (or html property).

```
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'CamperBot'
    }
  }
  render() {
    return (
       <div>
         <Navbar name={this.state.name}/>
       </div>
    );
  }
};

class Navbar extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
    <div>
      <h1>Hello, my name is: {this.props.name} </h1>
    </div>
    );
  }
};
```

#### Pass Callbacks to Children 
You can pass callback functions to child elements from their parents. In this example we pass the handleChange method from MyApp to one of its children: GetInput.

```
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      inputValue: ''
    }
    this.handleChange = this.handleChange.bind(this);
  }
  handleChange(event) {
    this.setState({
      inputValue: event.target.value
    });
  }
  render() {
    return (
       <div>
        { /* change code below this line */ }
        <GetInput input={this.state.inputValue} handleChange={this.handleChange}/>
        <RenderInput input={this.state.inputValue} />
        { /* change code above this line */ }
       </div>
    );
  }
};
```

### LifeCycle Methods 
React components have several special methods that provide opportunities to perform actions at specific points in the lifecycle of a component. These are called lifecycle methods, or lifecycle hooks, and allow you to catch components at certain points in time. This can be before they are rendered, before they update, before they receive props, before they unmount, and so on. When a page first loads, all components are mounted and this is where methods like componentWillMount() and componentDidMount() are called. After this, as state changes, components re-render themselves.

+ `componentWillMount()` method is called before the render() method when a component is being mounted to the DOM.
+ `componentDidMount()`. This method is called after a component is mounted to the DOM. Any calls to setState() here will trigger a re-rendering of your component. When you call an API in this method, and set your state with the data that the API returns, it will automatically trigger an update once you receive the data.  You can also add component event listeners here.
+ `componentWillUnmount()` When a react component is unrendered - it's good practice to remove any event listeners in this function body as well. 
+ `componentWillReceiveProps()` Called whenever a component is receiving new props.  You can use this argument and compare with `this.props` and perform actions before the component updates.  It's usually called `nextProps`
+ `componentDidUpdate()` called immediately after a component re-renders.
+ `shouldComponentUpdate()` This method is a useful way to optimize performance. For example, the default behavior is that your component re-renders when it receives new props, even if the props haven't changed. You can use shouldComponentUpdate() to prevent this by comparing the props. The method must return a boolean value that tells React whether or not to update the component. You can compare the current props (this.props) to the next props (nextProps) to determine if you need to update or not, and return true or false accordingly.

In this example of `componentDidMount` it triggers a mock API call with setTimeOut. Initially we see 50 activeUsers, then after 2.5 the function returns and triggers a re-build of the UI. 

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      activeUsers: 50
    };
  }
  componentDidMount() {
    setTimeout( () => {
      this.setState({
        activeUsers: 1273
      });
    }, 2500);
  }
  render() {
    return (
      <div>
        <h1>Active Users: {this.state.activeUsers}</h1>
      </div>
    );
  }
};
```

In this example we add two event listeners. 

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: ''
    };
    this.handleEnter = this.handleEnter.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
  }
  // change code below this line
  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyPress);
  }
  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyPress);
  }
  // change code above this line
  handleEnter() {
    this.setState({
      message: this.state.message + 'You pressed the enter key! '
    });
  }
  handleKeyPress(event) {
    if (event.keyCode === 13) {
      this.handleEnter();
    }
  }
  render() {
    return (
      <div>
        <h1>{this.state.message}</h1>
      </div>
    );
  }
};
```

In this example we call three of the lifecycle methods.  The order of the console.log statements show us the orider in which they're called.   

```
class Dialog extends React.Component {
  constructor(props) {
    super(props);
  }
  componentWillUpdate() {
    console.log('Component is about to update...');
  }
  // change code below this line
  componentWillReceiveProps(nextProps) {
    console.log(this.props.message);
    console.log(nextProps.message);
  }

  componentDidUpdate() {
    console.log('Component Updated');
  }
  // change code above this line
  render() {
    return <h1>{this.props.message}</h1>
  }
};

class Controller extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: 'First Message'
    };
    this.changeMessage = this.changeMessage.bind(this);
  }
  changeMessage() {
    this.setState({
      message: 'Second Message'
    });
  }
  render() {
    return (
      <div>
        <button onClick={this.changeMessage}>Update</button>
        <Dialog message={this.state.message}/>
      </div>
    );
  }
};
```

In this example we use `shouldComponentUpdate` to re-render the component only if the new props value is even 

```
class OnlyEvens extends React.Component {
  constructor(props) {
    super(props);
  }
  shouldComponentUpdate(nextProps, nextState) {
    console.log('Should I update?');
     // change code below this line
    return nextProps.value % 2 === 0 ? true : false;
     // change code above this line
  }
  componentWillReceiveProps(nextProps) {
    console.log('Receiving new props...');
  }
  componentDidUpdate() {
    console.log('Component re-rendered.');
  }
  render() {
    return <h1>{this.props.value}</h1>
  }
};

class Controller extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 0
    };
    this.addValue = this.addValue.bind(this);
  }
  addValue() {
    this.setState({
      value: this.state.value + 1
    });
  }
  render() {
    return (
      <div>
        <button onClick={this.addValue}>Add</button>
        <OnlyEvens value={this.state.value}/>
      </div>
    );
  }
};
```

### Styles
We can apply CSS styles to React elements the same way as JS.  Set the `className` attribute equal to an imported class from a stylesheet. We can also use inline-styling, here's an example of the syntax.
```
<div style={{color: "yellow", fontSize: 16}}>Mellow Yellow</div>
```
Hyphenated styles like `font-size` are changed to camelCase `fontSize`.  All property value units are assumed to be `px` unless otherwise specified.  Other than length values all other property values should be wrapped in quotes.  If you have a large number of styles you can declare an object and use that instead. 
```
const styles = {
  color: 'purple',
  fontSize: 40,
  border: '2px solid purple'
}
```

### Use javascript in methods
We can use advanced javascript in methods before we render the output.  Then when we want to render we just evaluate the JS (hopefully just a variable) in curly braces. 

```
const inputStyle = {
  width: 235,
  margin: 5
}

class MagicEightBall extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userInput: '',
      randomIndex: ''
    }
    this.ask = this.ask.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }
  ask() {
    if (this.state.userInput) {
      this.setState({
        randomIndex: Math.floor(Math.random() * 20),
        userInput: ''
      });
    }
  }
  handleChange(event) {
    this.setState({
      userInput: event.target.value
    });
  }
  render() {
    const possibleAnswers = [
      'It is certain',
      'It is decidedly so',
      'Without a doubt', 
      'Yes, definitely',
      'You may rely on it',
      'As I see it, yes',
      'Outlook good',
      'Yes',
      'Signs point to yes',
      'Reply hazy try again',
      'Ask again later',
      'Better not tell you now',
      'Cannot predict now',
      'Concentrate and ask again',
      'Don\'t count on it', 
      'My reply is no',
      'My sources say no',
      'Most likely',
      'Outlook not so good',
      'Very doubtful'
    ];
    const answer = possibleAnswers[this.state.randomIndex] // << change code here
    return (
      <div>
        <input
          type="text"
          value={this.state.userInput}
          onChange={this.handleChange}
          style={inputStyle} /><br />
        <button onClick={this.ask}>
          Ask the Magic Eight Ball!
        </button><br />
        <h3>Answer:</h3>
        <p>
          { /* change code below this line */ }
          {answer}
          { /* change code above this line */ }
        </p>
      </div>
    );
  }
};
```

### If/Else example 

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      display: true
    }
    this.toggleDisplay = this.toggleDisplay.bind(this);
  }
  toggleDisplay() {
    this.setState({
      display: !this.state.display
    });
  }
  render() {
    // change code below this line
    if(this.state.display) {
    return (
       <div>
         <button onClick={this.toggleDisplay}>Toggle Display</button>
         <h1>Displayed!</h1>
       </div>
    );
  } else {
    return (
       <div>
         <button onClick={this.toggleDisplay}>Toggle Display</button>
       </div>
    );
  }
  }
};
```

### &&
`&&` allows you to evaluate an expression and if true it can render the subsequent JSX markup.  This allows us to chain together more complex if/else blocks in a more concise manner. In this case we don't need a full if/else statement - we just use it to toggle the `h1` section. 

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      display: true
    }
    this.toggleDisplay = this.toggleDisplay.bind(this);
  }
  toggleDisplay() {
    this.setState({
      display: !this.state.display
    });
  }
  render() {
    // change code below this line
    return (
       <div>
         <button onClick={this.toggleDisplay}>Toggle Display</button>
         {this.state.display && <h1>Displayed!</h1>}
       </div>
    );
  }
};
```

+ This is the same xample using the `ternary` operator 

```
const inputStyle = {
  width: 235,
  margin: 5
}

class CheckUserAge extends React.Component {
  constructor(props) {
    super(props);
    // change code below this line
    this.state = {
      input: '',
      userAge: ''
    }
    // change code above this line
    this.submit = this.submit.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }
  handleChange(e) {
    this.setState({
      input: e.target.value,
      userAge: ''
    });
  }
  submit() {
    this.setState({
      userAge: this.state.input
    });
  }
  render() {
    const buttonOne = <button onClick={this.submit}>Submit</button>;
    const buttonTwo = <button>You May Enter</button>;
    const buttonThree = <button>You Shall Not Pass</button>;
    return (
      <div>
        <h3>Enter Your Age to Continue</h3>
        <input
          style={inputStyle}
          type="number"
          value={this.state.input}
          onChange={this.handleChange} /><br />
        {
          this.state.userAge == '' ? buttonOne : this.state.userAge >= 18 ? buttonTwo : buttonThree
        }
      </div>
    );
  }
};
```

### Change Inline CSS Based on State 
At this point, you've seen several applications of conditional rendering and the use of inline styles. Here's one more example that combines both of these topics. You can also render CSS conditionally based on the state of a React component. To do this, you check for a condition, and if that condition is met, you modify the styles object that's assigned to the JSX elements in the render method.

This paradigm is important to understand because it is a dramatic shift from the more traditional approach of applying styles by modifying DOM elements directly (which is very common with jQuery, for example). In that approach, you must keep track of when elements change and also handle the actual manipulation directly. It can become difficult to keep track of changes, potentially making your UI unpredictable. When you set a style object based on a condition, you describe how the UI should look as a function of the application's state. There is a clear flow of information that only moves in one direction. This is the preferred method when writing applications with React.

```

class GateKeeper extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: ''
    };
    this.handleChange = this.handleChange.bind(this);
  }
  handleChange(event) {
    this.setState({ input: event.target.value })
  }
  render() {
    let inputStyle = {
      border: '1px solid black'
    };
    // change code below this line
    if (this.state.input.length > 15) {
      inputStyle = {
        border: '3px solid red'
      };
    }
    // change code above this line
    return (
      <div>
        <h3>Don't Type Too Much:</h3>
        <input
          type="text"
          style={inputStyle}
          value={this.state.input}
          onChange={this.handleChange} />
      </div>
    );
  }
};
```

#### Dynamically render UI and unique sibling keys
Sometimes we need to dynamically generate JSX if we have an unknown number of inputs.  Here we use array.map to generate JSX based on user input.  Note that instead of using backticks ("`") or template literals, this map function just generates JSX without backticks or quotation marks. When you create an array of elements, each one needs a key attribute set to a unique value. React uses these keys to keep track of which items are added, changed, or removed. This helps make the re-rendering process more efficient when the list is modified in any way. Note that keys only need to be unique between sibling elements, they don't need to be globally unique in your application.

```
const textAreaStyles = {
  width: 235,
  margin: 5
};

class MyToDoList extends React.Component {
  constructor(props) {
    super(props);
    // change code below this line
    this.state = {
      userInput: '',
      toDoList: []
    }
    // change code above this line
    this.handleSubmit = this.handleSubmit.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }
  handleSubmit() {
    const itemsArray = this.state.userInput.split(',');
    this.setState({
      toDoList: itemsArray
    });
  }
  handleChange(e) {
    this.setState({
      userInput: e.target.value
    });
  }
  render() {
    const items = this.state.toDoList.map(el => <li>{el}</li>);
    return (
      <div>
        <textarea
          onChange={this.handleChange}
          value={this.state.userInput}
          style={textAreaStyles}
          placeholder="Separate Items With Commas" /><br />
        <button onClick={this.handleSubmit}>Create List</button>
        <h1>My "To Do" List:</h1>
        <ul>
          {items}
        </ul>
      </div>
    );
  }
};
```

In this example we generate a unique key for each sibling.  I just set the key equal to the name of the string 

```

const frontEndFrameworks = [
  'React',
  'Angular',
  'Ember',
  'Knockout',
  'Backbone',
  'Vue'
];

function Frameworks() {
  const renderFrameworks = frontEndFrameworks.map(el => <li key={el}>{el}</li>); // change code here
  return (
    <div>
      <h1>Popular Front End JavaScript Frameworks</h1>
      <ul>
        {renderFrameworks}
      </ul>
    </div>
  );
};
```

### Render React on the Server with renderToString
So far, you have been rendering React components on the client. Normally, this is what you will always do. However, there are some use cases where it makes sense to render a React component on the server. Since React is a JavaScript view library and you can run JavaScript on the server with Node, this is possible. In fact, React provides a renderToString() method you can use for this purpose.

There are two key reasons why rendering on the server may be used in a real world app. First, without doing this, your React apps would consist of a relatively empty HTML file and a large bundle of JavaScript when it's initially loaded to the browser. This may not be ideal for search engines that are trying to index the content of your pages so people can find you. If you render the initial HTML markup on the server and send this to the client, the initial page load contains all of the page's markup which can be crawled by search engines. Second, this creates a faster initial page load experience because the rendered HTML is smaller than the JavaScript code of the entire app. React will still be able to recognize your app and manage it after the initial load.

```

class App extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return <div/>
  }
};

// change code below this line
ReactDOMServer.renderToString(<App />);
```



## Redux 
Redux is a state management framework that can be used with a number of different web technologies, including React.

In Redux, there is a single state object that's responsible for the entire state of your application. This means if you had a React app with ten components, and each component had its own local state, the entire state of your app would be defined by a single state object housed in the Redux store. This is the first important principle to understand when learning Redux: the Redux store is the single source of truth when it comes to application state.

This also means that any time any piece of your app wants to update state, it must do so through the Redux store. The unidirectional data flow makes it easier to track state management in your app.  Here is an example store creation with a dummy reducer function: 

```
const reducer = (state = 5) => {
  return state;
}
const store = Redux.createStore(reducer);
```

**getState()** We can return state using the method `.getState`

```
const store = Redux.createStore(
  (state = 5) => state
);
const currentState = store.getState();
console.log(currentState); // returns 5
```

### Actions 
In redux we update state (a core task) by dispatching actions.  Actions are javascript objects that contain information about an event that occured.  Example `{type: 'LOGIN'}`.  Some actions may include optional data, but a `type` key is required.  Think of Redux actions as messengers that deliver information about events happening in your app to the Redux store.  

#### Action Creator 
Once we have an action template - the next step is to define an action creator that returns it.  This is just a javascript function that returns an action.  Here we define an action creator that returns a login action.  
```
const actionCreator = () => {
  return {type: 'LOGIN'}
}
```

#### Dispatch an action event 
In order to pass an action into the store we use the `dispatch` method.  Example: `store.dispatch(actionCreator())`.  Next, once an action is dispatched, the Redux store needs to respond to that action.  This is the job of a reducer function. Reducers in Redux are responsible for the state modifications that take place in response to actions. A reducer takes state and action as arguments, and it always returns a new state.  
  
Another key principle in Redux is that state is read-only. In other words, the reducer function must always return a new copy of state and never modify state directly. Redux does not enforce state immutability, however, you are responsible for enforcing it in the code of your reducer functions. 

```
const defaultState = {
  login: false
};

const reducer = (state = defaultState, action) => {
  if (action.type === 'LOGIN') {
    return {login: true};  // we need to return a new state here rather than setting state.login = true; then returning that object
  }
  return state;
};

const store = Redux.createStore(reducer);

const loginAction = () => {
  return {
    type: 'LOGIN'
  }
};
```

A common practice when working with Redux is to assign action types as read-only constants, then reference these constants wherever they are used.  It's generally a convention to write constants in all uppercase, and this is standard practice in Redux as well.

```
const LOGIN = 'LOGIN'; 
const LOGOUT = 'LOGOUT'

const defaultState = {
  authenticated: false
};

const authReducer = (state = defaultState, action) => {

  switch (action.type) {

    case LOGIN:
      return {
        authenticated: true
      }

    case LOGOUT:
      return {
        authenticated: false
      }

    default:
      return state;

  }

};

const store = Redux.createStore(authReducer);

const loginUser = () => {
  return {
    type: LOGIN
  }
};

const logoutUser = () => {
  return {
    type: LOGOUT
  }
};
```

#### Store Listener
Another method you have access to on the Redux store object is store.subscribe(). This allows you to subscribe listener functions to the store, which are called whenever an action is dispatched against the store. One simple use for this method is to subscribe a function to your store that simply logs a message every time an action is received and the store is updated. A callback function registered with the `subscribe` method is called every time you call `dispatch`.  There's no need to tell the event listener what to listen for - `subscribe` does this for you by default, every time an action is passed to the store using `dispatch`.

```
const ADD = 'ADD';

const reducer = (state = 0, action) => {
  switch(action.type) {
    case ADD:
      return state + 1;
    default:
      return state;
  }
};

const store = Redux.createStore(reducer);

// global count variable:
let count = 0;

const increaseCount = () => {count += 1;}
store.subscribe(increaseCount);

store.dispatch({type: ADD});
console.log(count);
store.dispatch({type: ADD});
console.log(count);
store.dispatch({type: ADD});
console.log(count);
```

#### Combine Multiple Reducers 
Redux provides reducer composition as a solution for a complex state model. You define multiple reducers to handle different pieces of your application's state, then compose these reducers together into one root reducer. The root reducer is then passed into the Redux createStore() method. In this example `counterReducer` and `authReducer` are the two reducer functions we define earlier. 

```
const rootReducer = Redux.combineReducers({
  count: counterReducer,
  auth: authReducer
});
```

#### Send Action Data to the Store 
When an action contains additional data we need to handle it.  Here the reducer functions returns `action.text` as the new state if the action has a case of ADD_NOTE.  The action creator function takes note text and returns an action of type: ADD_NOTE with an additional text property (data) that holds the text we want.  

```
const ADD_NOTE = 'ADD_NOTE';

const notesReducer = (state = 'Initial State', action) => {
  switch(action.type) {
    // change code below this line
    case (ADD_NOTE): 
      return action.text;
    // change code above this line
    default:
      return state;
  }
};

const addNoteText = (note) => {
  // change code below this line
  return {type: ADD_NOTE, text: note};
  // change code above this line
};

const store = Redux.createStore(notesReducer);

console.log(store.getState());
store.dispatch(addNoteText('Hello!'));
console.log(store.getState());
```

#### Redux Counter App 
This app counts state.  We have two consts that we use in our action creators and that we reference in the switch statement in the reducer function.  The reducer function returns and incremented or decremented state depending on which action type it recieves - if it receives neither then it returns an default state of 0 (or initialized state).  We pass this in to `createStore` to create the Redux store.  

```
const INCREMENT = 'INCREMENT'; 
const DECREMENT = 'DECREMENT'; 

const counterReducer = (state, action) => {
    switch (action.type) {
        case (INCREMENT):
            return state + 1;
        case (DECREMENT):
            return state - 1;
        default: 
            return 0;
    }
};

const incAction = () => {
    return {type: INCREMENT};
};
const decAction = () => {
    return {type: DECREMENT};
}; 
const store = Redux.createStore(counterReducer) ; 
```

#### Enforce Immuntability 
You are responsible for enforcing state immutability in your code. I found the following [link](https://www.samanthaming.com/tidbits/35-es6-way-to-clone-an-array) really helpful with this. All primitives are immutable string, number, boolean, null, undefined, and symbol.  Objects arrays and functions are however.  For arrays I found it most instructive to use `Array.from`, although the spread operator apparently works as well. It's important to note that the spread operator only makes a shallow copy of the array. That is to say, it only provides immutable array operations for one-dimensional arrays.

 

```
const ADD_TO_DO = 'ADD_TO_DO';

// A list of strings representing tasks to do:
const todos = [
  'Go to the store',
  'Clean the house',
  'Cook dinner',
  'Learn to code',
];

const immutableReducer = (state = todos, action) => {
  switch(action.type) {
    case ADD_TO_DO:
      let newState = Array.from(state);
      newState.push(action.todo);
      console.log(newState);
      return newState;
    default:
      return state;
  }
};

// an example todo argument would be 'Learn React',
const addToDo = (todo) => {
  return {
    type: ADD_TO_DO,
    todo
  }
}

const store = Redux.createStore(immutableReducer);
```

Spread Operator Example: 

```
const immutableReducer = (state = ['Do not mutate state!'], action) => {
  switch(action.type) {
    case 'ADD_TO_DO':
      let newState = [...state, action.todo];
      return newState;
    default:
      return state;
  }
};

const addToDo = (todo) => {
  return {
    type: 'ADD_TO_DO',
    todo
  }
}

const store = Redux.createStore(immutableReducer);
```

Remove an Item from an array without mutating state.  The array.prototype.concat method combines two arrays.   

```
const immutableReducer = (state = [0,1,2,3,4,5], action) => {
  switch(action.type) {
    case 'REMOVE_ITEM':
      let array1 = state.slice(0, action.index);
      let array2 = state.slice(action.index+1, state.length);
      return array1.concat(array2);
    default:
      return state;
  }
};

const removeItem = (index) => {
  return {
    type: 'REMOVE_ITEM',
    index
  }
}

const store = Redux.createStore(immutableReducer);
```

#### Middleware for asynchronous requests 
Sometimes we need to handle asynchronous API calls.  In this case we need to pass a second argument to the `createStore` method `Redux.applyMiddleware(ReduxThunk.default)`.  This handle async dispatch calls.  Then you need create an async function that returns a function that takes dispatch as an argument. Within this function, you can dispatch actions and perform asynchronous requests. Remember that you're passing dispatch as a parameter to this special action creator. This is what you'll use to dispatch your actions, you simply pass the action directly to dispatch and the middleware takes care of the rest.

```
const REQUESTING_DATA = 'REQUESTING_DATA'
const RECEIVED_DATA = 'RECEIVED_DATA'

const requestingData = () => { return {type: REQUESTING_DATA} }
const receivedData = (data) => { return {type: RECEIVED_DATA, users: data.users} }

const handleAsync = () => {
  return function(dispatch) {
    // dispatch request action here
    dispatch(requestingData());
    setTimeout(function() {
      let data = {
        users: ['Jeff', 'William', 'Alice']
      }
      // dispatch received data action here
    dispatch(receivedData(data));
    }, 2500);
  }
};

const defaultState = {
  fetching: false,
  users: []
};

const asyncDataReducer = (state = defaultState, action) => {
  switch(action.type) {
    case REQUESTING_DATA:
      return {
        fetching: true,
        users: []
      }
    case RECEIVED_DATA:
      return {
        fetching: false,
        users: action.users
      }
    default:
      return state;
  }
};

const store = Redux.createStore(
  asyncDataReducer,
  Redux.applyMiddleware(ReduxThunk.default)
);
```





#### Redux Questions 
Question: What is redux? 
Question: How many states does redux have? 
Question: What is a redux action?
Answer: An action is a javascript object that contains information about an action that occurred.  The store recieves actions - then updates its state accordingly.
Question: What property is required in a redux action? 
Answer: the "type" property is required - data is optional.    
Question: Redux state is read only.  What does this imply about changing state?
Answer: Whenever an action is sent to the store the reducer function must return a new state.  This implies state is immutable. 
Question: What is a reducer function? 
Question: What method retrieves the state from the Redux store? 
Answer: getState()

## React and Redux 
You need to use the "react-redux" package in order to use both React and Redux together. 

### Provider
Provider is a wrapper component from React Redux that wraps your React app. This wrapper then allows you to access the Redux store and dispatch functions throughout your component tree. Provider takes two props, the Redux store and the child components of your app. Defining the Provider for an App component might look like this:

```
<Provider store={store}>
  <App/>
</Provider>
```

Provider component allows you to provide state and dispatch to your React components, but you must specify exactly what state and actions you want. This way, you make sure that each component only has access to the state it needs. You accomplish this by creating two functions: `mapStateToProps()` and `mapDispatchToProps()`

### mapDispatchToProps
mapDispatchToProps() function is used to provide specific action creators to your React components so they can dispatch actions against the Redux store.


## Project 1 

+ Single quotes are not considered valid in JSON. Only use double quotes. 
+ When trying to use the fetch API to make an ajax request on a gist - you need to do so on the "raw" object, not the URL to github webpage of the gist. 
+ If GH recognizes your gist as json it also pretty-prints it.  This is a good way to check if your json is valid without using a third party validator.  

When you invoke the JQuery ajax method and call the success method, any variables you create here will be available globally. `quotesData` is now available in the rest of my app.  

```
const getQuotes = () => {
  $.ajax({
    headers: {
      Accept: "application/json"
    },
    url: endpoint,
    success: function(jsonQuotes) {
      if (typeof jsonQuotes === 'string') {
        // saves this as a global variable
        quotesData = JSON.parse(jsonQuotes);
        //console.log(quotesData);
      }
    }
  });
}
```

### Pass parent method down to children 
To call a parent method from a child we need to pass the method to the child from the parent as props.  React discourages using event bubbling because this creates another data flow in the opposite direction.  In this example I pass down the `newQuote` method to an intermediate child, which then passes it down again to a stateless functional component. 

```
class QuoteBox extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isLoaded: false,
      quotes: [],
      quote: 'Ah music, a magic beyond all those we teach here',
      speaker: 'Albus Dumbledore'
    };
    this.logState = this.logState.bind(this);
    this.newQuote = this.newQuote.bind(this);
  }
  componentDidMount() {
    fetch(endpoint)
      .then(blob => blob.json())
      .then((data) => {
      this.setState({
        isLoaded: true,
        quotes: data["quotes"]
      });
    });
  }
  logState() {
    console.log(this.state);
  }
  newQuote() {
    const index = Math.floor(Math.random()*this.state.quotes.length);
    this.setState({
      quote: this.state.quotes[index].quote,
      speaker: this.state.quotes[index].speaker
    });
    //console.log(this.state);
  }
  render() {
    return (
      <div id='quote-box'>
        <Text quote={this.state.quote}/>
        <Speaker speaker={this.state.speaker} />
        <RowOfButtons newQuote={this.newQuote}/>
      </div>
    );
  }
};

// container element for three buttons
class RowOfButtons extends React.Component {
  constructor(props) {
    super(props);
  }
  // Pass parent method down to child 
  newQuote = () => {
    this.props.newQuote();
  }
  render () {
    return (
    <div>
      <TweetButton />
      <NewQuoteButton newQuote={this.newQuote}/>
    </div>
    )};
};

const NewQuoteButton = (props) => {
  return (
    <button id='new-quote' onClick={props.newQuote}>New Quote!</button>
  );
}
```